WebSphere Message BrokerESQLVersion 6 Release 1

Developing ESQLCustomize processing implemented by the Compute, Database, and Filter nodes inyour message flows by coding ESQL.You must create, for each node, an ESQL module in which you code the ESQLstatements and functions to tailor the behavior of the node. You can accessmessage content, or database content, or both, to achieve the results that yourequire. ESQL modules are maintained in ESQL files, managed through the BrokerApplication Development perspective.This section provides information about:v “ESQL overview”v “Managing ESQL files” on page 13v “Writing ESQL” on page 25You can use the ESQL debugger, which is part of the flow debugger, to debug thecode that you write. The debugger steps through ESQL code statement bystatement, so that you can view and check the results of every line of code that isexecuted.ESQL overviewExtended Structured Query Language (ESQL) is a programming language definedby WebSphere® Message Broker to define and manipulate data within a messageflow.This section contains introductory information about ESQL.v For descriptions of ESQL user tasks, see “Writing ESQL” on page 25.v For reference information about ESQL, see “ESQL reference” on page 159.Read the following information before you proceed:v An overview of message flows in Message flows overview.v An overview of message trees in The message tree, and the topics within thiscontainer, paying special attention to Logical tree structure.ESQL is based on Structured Query Language (SQL) which is in common usagewith relational databases such as DB2®. ESQL extends the constructs of the SQLlanguage to provide support for you to work with message and database contentto define the behavior of nodes in a message flow.The ESQL code that you create to customize nodes within a message flow isdefined in an ESQL file, typically named <message_flow_name>.esql,, which isassociated with the message flow project. You can use ESQL in the followingbuilt-in nodes:v Compute nodev Database nodev Filter nodeYou can also use ESQL to create functions and procedures that you can use in thefollowing built-in nodes:v DataDelete node© Copyright IBM Corp. 2000, 20103
v DataInsert nodev DataUpdate nodev Extract nodev Mapping nodev Warehouse nodeTo use ESQL correctly and efficiently in your message flows, you must alsounderstand the following concepts:v Data typesv Variablesv Field referencesv Operatorsv Statementsv Functionsv Proceduresv ModulesUse the ESQL debugger, which is part of the flow debugger, to debug the code thatyou write. The debugger steps through ESQL code statement by statement, so thatyou can view and check the results of every line of code that is executed.ESQL data typesA data type defines the characteristics of an item of data, and determines how thatdata is processed. ESQL supports six data types, listed later in this section. Datathat is retrieved from databases, received in a self-defining message, or defined ina message model (using MRM data types), is mapped to one of these basic ESQLtypes when it is processed in ESQL expressions.Within a broker, the fields of a message contain data that has a definite data type.It is also possible to use intermediate variables to help process a message. Youmust declare all such variables with a data type before use. A variable's data typeis fixed; If you try to assign values of a different type you get either an implicitcast or an exception. Message fields do not have a fixed data type, and you canassign values of a different type. The field adopts the new value and type.It is not always possible to predict the data type that results from evaluating anexpression. This is because expressions are compiled without reference to any kindof message schema, and so some type errors are not caught until run time.ESQL defines the following categories of data. Each category contains one or moredata types.v Booleanv Datetimev Nullv Numericv Referencev StringESQL variablesAn ESQL variable is a data field that is used to help process a message.You must declare a variable and state its type before you can use it. A variable'sdata type is fixed; if you code ESQL that assigns a value of a different type, eitheran implicit cast to the data type of the target is implemented or an exception israised (if the implicit cast is not supported).4ESQL
To define a variable and give it a name, use the DECLARE statement.The names of ESQL variables are case sensitive; therefore, make sure that you usethe correct case in all places. The simplest way to guarantee that you are using thecorrect case is always to define variables using uppercase names.The workbench marks variables that have not been defined. Remove all thesewarnings before deploying a message flow.You can assign an initial value to the variable on the DECLARE statement. If aninitial value is not specified, scalar variables are initialized with the special valueNULL, and ROW variables are initialized to an empty state. Subsequently, you canchange the variable's value using the SET statement.Three types of built-in node can contain ESQL code and therefore support the useof ESQL variables:v Compute nodev Database nodev Filter nodeVariable scope, lifetime, and sharingHow widespread and for how long a particular ESQL variable is available, isdescribed by its scope, lifetime, and sharing:A variable's scopeis a measure of the range over which it is visible. In the brokerenvironment, the scope of variables is typically limited to the individualnode.A variable's lifetimeis a measure of the time for which it retains its value. In the brokerenvironment, the lifetime of a variable varies but is typically restricted tothe life of a thread within a node.A variable's sharing characteristicsindicate whether each thread has its own copy of the variable or onevariable is shared between many threads. In the broker environment,variables are typically not shared.Types of variableExternalExternal variables (defined with the EXTERNAL keyword) are also knownas user-defined properties, see “User-defined properties in ESQL” on page 6.They exist for the entire lifetime of a message flow and are visible to allmessages passing through the flow. You can define external variables only atthe module and schema level. You can modify their initial values(optionally set by the DECLARE statement) at design time, using theMessage Flow editor, or at deployment time, using the Broker Archiveeditor. You can query and set the values of user-defined properties at runtime by using the Configuration Manager Proxy (CMP). For moreinformation, see Setting user-defined properties at run time in a CMPapplication.NormalNormal variables variables have a lifetime of just one message passingDeveloping ESQL5
through a node. They are visible to that message only. To define a normalvariables, omit both the EXTERNAL and SHARED keywords.SharedShared variables can be used to implement an in-memory cache in themessage flow, see Optimizing message flow response times. Shared variableshave a long lifetime and are visible to multiple messages passing through aflow, see “Long-lived variables” on page 7. They exist for the lifetime ofthe execution group process, the lifetime of the flow or node, or thelifetime of the node's SQL that declares the variable (whichever is theshortest). They are initialized when the first message passes through theflow or node after each broker startup.See also the ATOMIC option of the “BEGIN ... END statement” on page191. The BEGIN ATOMIC construct is useful when a number of changesneed to be made to a shared variable and it is important to prevent otherinstances seeing the intermediate states of the data.For information about specific types of variable, see:v “User-defined properties in ESQL” (external variables)v “Long-lived variables” on page 7 (shared variables)User-defined properties in ESQLYou can access user-defined properties (UDPs) as variables in your ESQL programby specifying the EXTERNAL keyword on a DECLARE statement. For example,the ESQL statement DECLARE today EXTERNAL CHARACTER 'monday' defines auser-defined property called today with an initial value monday.Before you can use a user-defined property, you must define the property in theMessage Flow editor when you construct a message flow that uses it. When youdefine a UDP in the Message Flow editor, you must define a value and theproperty type. The value can be a default value, which varies according to the typeof the UDP. The value that is assigned to the UDP in the Message Flow editortakes precedence over a value that you have assigned to the UDP in your ESQLprogram.you can also define a UDP for a subflow. A UDP has global scope and is notspecific to a particular subflow. If you reuse a subflow in a message flow, andthose subflows have identical UDPs, you cannot set the UDPs to different values.Before you deploy the message flow that uses the UDP, you can change the valueof the UDP in the Broker Archive editor. If you try to deploy a message flow thatcontains a UDP that has had no value assigned to it, a deployment failure occurs.For more information, see “Configuring a message flow at deployment time withuser-defined properties” on page 154.You can use UDPs to set configuration data, and use them like typical properties.No external calls to user-written plug-ins or parsing of environment trees areinvolved, and parsing costs of reading data out of trees are removed. The value ofthe UDP is finalized in the variable at deployment time.You can declare UDPs only in modules or schemas. You can query, discover, andset UDPs at run time, to dynamically change the behavior of a message flow. Formore information, see User-defined properties.You can access UDPs from the following built-in nodes that use ESQL:v Compute6ESQL|||
v Databasev FilterFor a description of how to access a UDP from a JavaCompute node, see Accessingmessage flow user-defined properties from a JavaCompute node.Long-lived variablesYou can use appropriate long-lived ESQL data types to cache data in memory.Sometimes data has to be stored beyond the lifetime of a single message passingthrough a flow. One way to store this data is to store the data in a database. Usinga database is good for long-term persistence and transactionality, but access(particularly write access) is slow.Alternatively, you can use appropriate long-lived ESQL data types to provide anin-memory cache of the data for a certain period of time. Using long-lived ESQLdata types makes access faster than from a database, although this speed is at theexpense of shorter persistence and no transactionality.You create long-lifetime variables by using the SHARED keyword on theDECLARE statement. For further information, see “DECLARE statement” on page235.The following sample demonstrates how to define shared variables using theDECLARE statement. The sample demonstrates how to store routing informationin a database table and use shared variables to store the database table in memoryin the message flow to improve performance.v Message RoutingYou can view samples information only when you use the information center thatis integrated with the Message Broker Toolkit or the online information center.Long-lived data types have an extended lifetime beyond that of a single messagepassing through a node. Long-lived data types are shared between threads andexist for the life of a message flow (strictly speaking the time betweenconfiguration changes to a message flow), as described in the following table.ScopeLifeSharedShort lifetime variablesSchema & ModuleNodeThread withinnodeNot at allRoutine LocalNodeThread withinroutineNot at allBlock LocalNodeThread withinblockNot at allLong lifetime variablesNode SharedNodeLife of nodeAll threads of flowFlow SharedFlowLife of flowAll threads of flowFeatures of long-lived ESQL data types include:v The ability to handle large amounts of long-lifetime data.v The joining of data to messages fast.Developing ESQL7
v On multiple processor machines, multiple threads can access the same datasimultaneously.v Subsequent messages can access the data left by a previous message.v Long lifetime read-write data can be shared between threads, because there is nolong-term association between threads and messages.v In contrast to data stored in database tables in the environment, this type of datais stored privately; that is, within the broker.v ROW variables can be used to create a modifiable copy of the input message;see “ESQL ROW data type” on page 169.v It is possible to create shared constants.A typical use of these data types might be in a flow in which data tables are'read-only' as far as the flow is concerned. Although the table data is not actuallystatic, the flow does not change it, and thousands of messages pass through theflow before there is any change to the table data.Examples include:v A table which contains a day's credit card transactions. The table is created eachday and that day's messages are run against it. Then the flow is stopped, thetable updated and the next day's messages run. These flows might performbetter if they cache the table data rather than read it from a database for eachmessage.v The accumulation and integration of data from multiple messages.Broker propertiesFor each broker, WebSphere Message Broker maintains a set of properties. You canaccess some of these properties from your ESQL programs. A subset of theproperties is also accessible from Java™programs. It can be useful, at run time, tohave real-time access to details of a specific node, flow, or broker.Broker properties are divided into four categories:v Properties that relate to a specific nodev Properties that relate to nodes in generalv Properties that relate to a message flowv Properties that relate to the execution groupFor a description of the broker, flow, and node properties that are accessible fromESQL and Java, see “Broker properties that are accessible from ESQL and Java” onpage 377.Broker properties have the following characteristics.v They are grouped by broker, execution group, flow, and node.v They are case sensitive. Their names always start with an uppercase letter.v They return NULL if they do not contain a value.All nodes that allow user programs to edit ESQL support access to brokerproperties. These nodes are:v Compute nodesv Database nodesv Filter nodesv All derivatives of these nodes8ESQL
User-defined properties can be queried, discovered, and set at run time todynamically change the behavior of a message flow. You can use the ConfigurationManager Proxy (CMP) API to manipulate these properties, which can be used by asystems monitoring tool to perform automated actions in response to situationsthat it detects in the monitored systems. For more information, see User-definedproperties.A complex property is a property to which you can assign multiple values. Complexproperties are displayed in a table in the Properties view, where you can add, edit,and delete values, and change the order of the values in the table. You cannotpromote complex properties; therefore, they do not appear in the Promoteproperties dialog box. Nor can you configure complex properties; therefore, theyare not supported in the Broker Archive editor. For an example of a complexproperty, see the Query elements property of the DatabaseRoute node.For more information about editing a node's properties, see Configuring a messageflow node.ESQL field referencesAn ESQL field reference is a sequence of period-separated values that identify aspecific field (which might be a structure) within a message tree or a databasetable.The path from the root of the information to the specific field is traced using theparent-child relationships.A field reference is used in an ESQL statement to identify the field that is to bereferenced, updated, or created within the message or database table. For example,you might use the following identifier as a message field reference:You can use an ESQL variable of type REFERENCE to set up a dynamic pointer tocontain a field reference. This might be useful in creating a fixed reference to acommonly-referenced point within a message; for example the start of a particularstructure that contains repeating fields.A field reference can also specify element types, XML namespace identifications,indexes and a type constraint; see “ESQL field reference overview” on page 174 forfurther details.The first name in a field reference is sometimes known as a Correlation name.ESQL operatorsAn ESQL operator is a character or symbol that you can use in expressions tospecify relationships between fields or values.ESQL supports the following groups of operators:v Comparison operators, to compare one value to another value (for example, lessthan). Refer to “ESQL simple comparison operators” on page 181 and “ESQLcomplex comparison operators” on page 182 for details of the supportedoperators and their use.v Logical operators, to perform logical operations on one or two terms (forexample, AND). Refer to “ESQL logical operators” on page 185 for details of thesupported operators and their use.Body.Invoice.PaymentDeveloping ESQL9||||
v Numeric operators, to indicate operations on numeric data (for example, +).Refer to “ESQL numeric operators” on page 186 for details of the supportedoperators and their use.There are some restrictions on the application of some operators to data types; notall lead to a meaningful operation. These are documented where they apply toeach operator.Operators that return a Boolean value (TRUE or FALSE), for example the greaterthan operator, are also known as predicates.ESQL statementsAn ESQL statement is an instruction that represents a step in a sequence of actionsor a set of declarations.ESQL provides a large number of different statements that perform different typesof operation. All ESQL statements start with a keyword that identifies the type ofstatement and end with a semicolon. An ESQL program consists of a number ofstatements that are processed in the order they are written.As an example, consider the following ESQL program:This program consists of two statements. The first starts with the keywordDECLARE and ends at the first semicolon. The second statement starts with thekeyword SET and ends at the second semicolon. These two statements are writtenon separate lines and it is conventional (but not required) that they be so. You willnotice that the language keywords are written in capital letters. This is also theconvention but is not required; mixed case and lowercase are acceptable.The first statement declares a variable called x of type INTEGER, that is, it reservesa space in the computer's memory large enough to hold an integer value andallows this space to be subsequently referred to in the program by the name x. Thesecond statement sets the value of the variable x to 42. A number appearing in anESQL program without decimal point and not within quotation marks is known asan integer literal.ESQL has a number of data types and each has its own way of writing literalvalues. These are described in “ESQL data types” on page 4.For a full description of all the ESQL statements, see “ESQL statements” on page188.ESQL nested statementsAn ESQL nested statement is a statement that is contained within anotherstatement.Consider the following ESQL program fragment:DECLARE x INTEGER;SET x = 42;10ESQL
In this example, you can see a single IF statement containing the optional ELSEclause. Both the IF and ELSE portions contain three nested statements. Thosewithin the IF clause are processed if the operator > (greater than) returns the valueTRUE (that is, if Size has a value greater than 100.00); otherwise, those within theELSE clause are processed.Many statements can have expressions nested within them, but only a few canhave statements nested within them. The key difference between an expression anda statement is that an expression calculates a value to be used, whereas a statementperforms an action (usually changing the state of the program) but does notproduce a value.ESQL functionsA function is an ESQL construct that calculates a value from a number of giveninput values.A function usually has input parameters and can, but does not usually have,output parameters. It returns a value calculated by the algorithm described by itsstatement. This statement is usually a compound statement, such as BEGIN... END,because this allows an unlimited number of nested statements to be used toimplement the algorithm.ESQL provides a number of predefined, or “built-in”, functions which you can usefreely within expressions. You can also use the CREATE FUNCTION statement todefine your own functions.When you define a function, you must give it a unique name. The name ishandled in a case insensitive way (that is, use of the name with any combinationof uppercase and lowercase letters matches the declaration). This is in contrast tothe names that you declare for schemas, constants, variables, and labels, which arehandled in a case sensitive way, and which you must specify exactly as youdeclared them.Consider the following ESQL program fragment:In this example, the function SQRT (square root) is given the value inside thebrackets (itself the result of an expression, a divide operation) and its result is usedin a further expression, a multiply operation. Its return value is assigned to thevariable Diameter. See “Calling ESQL functions” on page 278 for information aboutall the built-in ESQL functions.In addition, an ESQL expression can refer to a function in another broker schema(that is, a function defined by a CREATE FUNCTION statement in an ESQL file inthe same or in a different dependent project). To resolve the name of the calledfunction, you must do one of the following:IF Size> 100.00 THENSET X = 0;SET Y = 0;SET REVERSE = FALSE;ELSESET X = 639;SET Y = 479;SET REVERSE = TRUE;END IF;SET Diameter = SQRT(Area / 3.142) * 2;Developing ESQL11
v Specify the fully-qualified name (<SchemaName>.<FunctionName>) of the calledfunction.v Include a PATH statement to make all functions from the named schema visible.Note that this technique only works if the schemas do not containidentically-named functions. The PATH statement must be coded in the sameESQL file, but not within any MODULE.Note that you cannot define a function within an EVAL statement or an EVALfunction.ESQL proceduresAn ESQL procedure is a subroutine that has no return value. It can accept inputparameters from, and return output parameters to, the caller.Procedures are very similar to functions. The main difference between them is that,unlike functions, procedures have no return value. Thus they cannot form part ofan expression and are invoked by using the CALL statement. Procedurescommonly have output parametersYou can implement a procedure in ESQL (an internal procedure) or as a databasestored procedure (an external procedure). The ESQL procedure must be a singleESQL statement, although that statement can be a compound statement such asBEGIN END. You cannot define a procedure within an EVAL statement or anEVAL function.When you define a procedure, give it a name. The name is handled in a caseinsensitive way (that is, use of the name with any combination of uppercase andlowercase letters matches the declaration). That is in contrast to the names that youdeclare for schemas, constants, variables, and labels, which are handled in a casesensitive way, and which you must specify exactly as you declared them.An ESQL expression can include a reference to a procedure in another brokerschema (defined in an ESQL file in the same or a different dependent project). Ifyou want to use this technique, either fully qualify the procedure, or include aPATH statement that sets the qualifier. The PATH statement must be coded in thesame ESQL file, but not within a MODULE.An external database procedure is indicated by the keyword EXTERNAL and theexternal procedure name. This procedure must be defined in the database and inthe broker, and the name specified with the EXTERNAL keyword and the name ofthe stored database procedure must be the same, although parameter names do nothave to match. The ESQL procedure name can be different from the external nameit defines.Overloaded procedures are not supported to any database. (An overloadedprocedure is one that has the same name as another procedure in the samedatabase schema which has a different number of parameters, or parameters withdifferent types.) If the broker detects that a procedure has been overloaded, itraises an exception.Dynamic schema name resolution for stored procedures is supported; when youdefine the procedure you must specify a wildcard for the schema that is resolvedbefore invocation of the procedure by ESQL. This is explained further in “Invokingstored procedures” on page 77.12ESQL
ESQL modulesA module is a sequence of declarations that define variables and their initialization,and a sequence of subroutine (function and procedure) declarations that define aspecific behavior for a message flow node.A module must begin with the CREATE node_type MODULE statement and end withan END MODULE statement. The node_type must be one of COMPUTE, DATABASE,or FILTER. The entry point of the ESQL code is the function named MAIN, whichhas MODULE scope.Each module is identified by a name which follows CREATE node_type MODULE. Thename might be created for you with a default value, which you can modify, or youcan create it yourself. The name is handled in a case insensitive way (that is, use ofthe name with any combination of uppercase and lowercase letters matches thedeclaration). That is in contrast to the names that you declare for schemas,constants, variables, and labels, which are handled in a case sensitive way, andwhich you must specify exactly as you declared them.You must create the code for a module in an ESQL file which has a suffix of .esql.You must create this file in the same broker schema as the node that references it.There must be one module of the correct type for each corresponding node, and itis specific to that node and cannot be used by any other node.When you create an ESQL file (or complete a task that creates one), you indicatethe message flow project and broker schema with which the file is associated aswell as specifying the name for the file.Within the ESQL file, the name of each module is determined by the value of thecorresponding property of the message flow node. For example, the property ESQLModule for the Compute node specifies the name of the node's module in the ESQLfile. The default value for this property is the name of the node. You can specify adifferent name, but you must ensure that the value of the property and the nameof the module that provides the required function are the same.The module must contain the function MAIN, which is the entry point for themodule. This is included automatically if the module is created for you. WithinMAIN, you can code ESQL to configure the behavior of the node. If you includeESQL within the module that declares variables, constants, functions, andprocedures, these are of local scope only and can be used within this singlemodule.If you want to reuse ESQL constants, functions, or procedures, you must declarethem at broker schema level. You can then refer to these from any resource withinthat broker schema, in the same or another project. If you want to use thistechnique, either fully qualify the procedure, or include a PATH statement that setsthe qualifier. The PATH statement must be coded in the same ESQL file, but notwithin any MODULE.Managing ESQL filesWithin a message flow project, you can create ESQL files to contain the ESQL codethat you provide to modify or customize the behavior of Compute, Database, orFilter nodes.Developing ESQL13
The ESQL code is contained within a module that is associated with the node.Each module must be created within an ESQL file. The name of the module withinthe ESQL file must match the name specified for the module in the ESQL Moduleproperty of the corresponding node. Although you can modify the module name,and change it from its default value (which is the name of the message flow,concatenated with the name of the node with which the module is associated),ensure that the module in the ESQL file matches the node property.The following topics describe how you can manage these files:v “Creating an ESQL file”v “Opening an existing ESQL file” on page 15v “Creating ESQL for a node” on page 16v “Modifying ESQL for a node” on page 19v “Saving an ESQL file” on page 20v “Copying an ESQL file” on page 21v “Renaming an ESQL file” on page 21v “Moving an ESQL file” on page 22v “Changing ESQL preferences” on page 23v “Deleting ESQL for a node” on page 24v “Deleting an ESQL file” on page 25Creating an ESQL fileWhen you include a node in your message flow that requires ESQL to customizeits function (the Compute, Database, and Filter nodes), you must code the ESQLstatements that provide the customization in an ESQL module within an ESQL file.You can use the same ESQL file for more than one module.Before you startTo complete this task, you must have completed the following task:v Creating a message flow projectESQL files are stored in a file system or in a shared repository. If you are using afile system, this can be the local file system or a shared drive. If you store files in arepository, you can use any of the available repositories that are supported byEclipse, for example CVS.To create an ESQL file:1. Switch to the Broker Application Development perspective.2. Click File →New →Message Flow ESQL File.You can also press Ctrl+N. This displays a dialog box that allows you to selectthe wizard to create a new object. Click Message Brokers in the left view; theright view displays a list of objects that you can create for WebSphere MessageBroker. Click Message Flow ESQL File in the right view, then click Next. TheNew Message Flow ESQL File wizard is displayed.3. Enter the name of the message flow project in which to create the ESQL file.You must enter the name of an existing message flow project. The dialog box isdisplayed with the current project name entered in the project name field. Youcan accept this value or change it to specify a different project. You can alsoclick Browse to view a list of valid projects (projects that are defined anddisplayed in the Navigator view), and select the appropriate value from thatlist. The list is filtered to only show projects in the active working set.14ESQL
If you type in the name of a project that does not exist, the error message Thespecified project does not exist is displayed in the dialog box and youcannot continue until you specify a valid project name.4. If you want the ESQL file to be defined within a specific broker schema, enterthe name of the broker schema in the appropriate entry field, or click Browseto select the broker schema from the list of valid broker schema for this project.(If only the default broker schema is defined in this project, Browse isdisabled.)5. Enter a name for the new ESQL file. If you enter a name that is already in usefor an ESQL file in this project, the error message The resource <name>.esqlalready exists is displayed in the dialog box and you cannot continue untilyou specify a valid name.When creating ESQL files, the overall file path length must not exceed 256characters, due to a Windows file system limitation. If you try to add amessage flow to a broker archive file with ESQL or mapping files with a pathlength that exceeds 256 characters, the compiled message flow will not begenerated and cannot be deployed. Therefore, make sure that the names ofyour ESQL files, mapping files, projects, and broker schema are as short aspossible.An ESQL file can also be created automatically for you. If you select Open ESQLfrom the menu displayed when you right-click a Compute, Database, or Filternode, and the module identified by the appropriate property does not already existwithin the broker schema, a module is automatically created for you. This iscreated in the file <message_flow_name>.esql in the same broker schema within thesame project as the <message_flow_name>.msgflow file. If that ESQL file does notalready exist, that is also created for you.The contents of a single ESQL file do not have any specific relationship withmessage flows and nodes. It is your decision which modules are created in whichfiles (unless the specified module, identified by the appropriate property, is createdby default in the file <message_flow_name>.esql as described above). Monitor thesize and complexity of the ESQL within each file, and split the file if it becomesdifficult to view or manage.If you create reusable subroutines (at broker schema level) within an ESQL file,you might want to refer to these routines from ESQL modules in another project.To do this, specify that the project that wants to invoke the subroutines dependson the project in which the ESQL file containing them is defined. You can specifythis when you create the second project, or you can update project dependenciesby selecting the project, clicking Properties, and updating the dependencies in theProject Reference page of the Properties dialog box.Opening an existing ESQL fileYou can add to and modify ESQL code that you have created in an ESQL file in amessage flow project.Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To open an existing ESQL file:1. Switch to the Broker Application Development perspective.Developing ESQL15
2. In the Broker Development view, double-click the ESQL file that you want toopen. The file is opened in the editor view.3. Work with the contents of file to make your changes. The file can containmodules relating to specific nodes in a message flow, PATH statements, anddeclarations at broker schema level such as reusable constants and procedures.Scroll through the file to find the specific content that you want to work with.4. You can select the content that you want to work with by selecting its name inthe Outline view. The code for the selected resource is highlighted.You can also open an ESQL file when you have a message flow open in the editorview by selecting an appropriate node (of type Compute, Database, or Filter),right-clicking, and selecting Open ESQL. In this case, the ESQL file that containsthis module is opened, and the module for the selected node is highlighted in theeditor view.Creating ESQL for a nodeCreate ESQL to customize the behavior of a Compute, Database, or Filter nodewithin an ESQL file.Before you startComplete the following task:v “Creating an ESQL file” on page 14Within the ESQL file, create a module that is associated with a node in yourmessage flow. A module can be associated with only one node of a particular type(Compute, Database, or Filter). Within the module you can create and usefunctions and procedures as well as the supplied statements and functions. Youcan also create local constants and variables.If you have created constants, functions, or procedures at the broker schema level,you can also refer to these within the module. You can define routines at a level atwhich many different modules can use them, which can save you developmenttime and maintenance effort.To create ESQL for a node:1. Switch to the Broker Application Development perspective.2. In the Broker Development view, double-click the message flow that includesthe node for which you want to create ESQL. The message flow opens in theeditor view.3. Right-click the node (which must be Compute, Database, or Filter) and thenclick Open ESQL. The default ESQL file for this message flow,message_flow_name.esql, is opened in the editor view. The file is created if itdoes not already exist.If you have already created the file, it is opened in the editor view and a newmodule is created and highlighted. If the file is created for you, it contains askeleton module for this node at the end. Its exact content depends on the typeof node.The following module is created for a Compute node:16ESQL
The module name is determined by the value that you have set for thecorresponding node property. The default is message_flow_name_node_type. TheMain function contains calls to two procedures, described in the following list,that are declared within the Compute node module following the functionMain. These calls are commented out. If you want to include the function thatthey provide, uncomment the lines and place them at the appropriate point inthe ESQL that you create for Main.CopyMessageHeadersThis procedure loops through the headers contained in the inputmessage and copies each one to the output message.CopyEntireMessageThis procedure copies the entire contents of the input message,including the headers, to the output message.If you create an ESQL module for a Database node, the following module iscreated:For a Filter node, the module is identical to that created for the Database nodeexcept for the first line, which reads:4. Add ESQL to this file to customize the behavior of the node.Start by adding ESQL statements within the Main function, that is after theBEGIN statement, and before RETURN TRUE. You can add DECLAREstatements within the module that are not within the Main function. To add anew line into the file, press Enter.To help you to code valid ESQL, the editor displays a list of valid statementsand functions at the point of the cursor. To invoke this assistance, click Edit →Content Assist. On some systems, you can use the key combination Ctrl+Space.CREATE COMPUTE MODULE module_nameCREATE FUNCTION Main() RETURNS BOOLEANBEGIN-- CALL CopyMessageHeaders();-- CALL CopyEntireMessage();RETURN TRUE;END;CREATE PROCEDURE CopyMessageHeaders() BEGINDECLARE I INTEGER 1;DECLARE J INTEGER CARDINALITY(InputRoot.*[]);WHILE I < J DOSET OutputRoot.*[I] = InputRoot.*[I];SET I = I + 1;END WHILE;END;CREATE PROCEDURE CopyEntireMessage() BEGINSET OutputRoot = InputRoot;END;END MODULE;CREATE DATABASE MODULE module_nameCREATE FUNCTION Main() RETURNS BOOLEANBEGINRETURN TRUE;END;END MODULE;CREATE FILTER MODULE module_nameDeveloping ESQL17
Scroll through the list displayed to find and highlight the one that you want,and press Enter. The appropriate code is inserted into your module, and the listdisappears.Content assistance is provided in the following areas:v Applicable keywords, based on language syntax.v Blocks of code that go together, such as BEGIN END;.v Constants that you have defined, identifiers, labels, functions, andprocedures that can be used, where the routines can be in any projects, evenif the current project does not reference them.v Database schema and table names after the database correlation name, aswell as table column names in INSERT, UPDATE, DELETE, and SELECTstatements, and, in most cases, the WHERE clauses of those statements.v Elements of message field reference: runtime domain (parser) names, formatof type expression, namespace identifiers, namespace-qualified element andattribute names, and format of index expression.v Content in the Properties folder under the output message root.v For the DECLARE NAMESPACE statement, target namespaces of messagesets and schema names.Content assistance works only if the ESQL can be parsed correctly. Errors suchas END missing after BEGIN, and other unterminated block statements, causeparser failures and no content assistance is provided. Try content assistance inother areas around the statement where it does not work to narrow down thepoint of error. Alternatively, save the ESQL file; saving the file causesvalidation, and all syntax errors are written to the Problems view. Refer to theerrors reported to understand and correct the ESQL syntax. If you use contentassistance to generate most statements (such as block statements), these arecorrectly entered and there is less opportunity for error.5. When you have finished working with this module, you can close the ESQLfile. Save the file before you close it to retain all your changes and validateyour ESQL.If you prefer, you can open the ESQL file directly and create the module withinthat file using the editor:1. Switch to the Broker Application Development perspective.2. Select the ESQL file in which you want to create the module. Eitherdouble-click to open this file in the editor view, or right-click and click Open.3. In the editor view, position your cursor on a new line and use contentassistance to select the appropriate module skeleton for this type of node, forexample CREATE COMPUTE MODULE END MODULE;. You can type this text in yourselfif you prefer, but you must ensure that what you type is consistent with therequired skeleton, shown earlier. Use content assistance to give you additionalhelp by inserting only valid ESQL, and by inserting matching end statements(for example, END MODULE;) where these are required.4. Complete the coding of the module as appropriate.Whichever method you use to open the ESQL file, be aware that the editorprovides functions to help you to code ESQL. This section refers to contentassistance; other functions are available. For information about these functions, seeESQL editor.18ESQL
Modifying ESQL for a nodeIf you want to change the customization of a node that requires ESQL (Compute,Database, or Filter), you can modify the ESQL statements within the module thatyou created for that node.Before you startTo complete this task, you must have completed the following task:v “Creating ESQL for a node” on page 16To modify ESQL code:1. Switch to the Broker Application Development perspective.2. In the Broker Development view, select the message flow that you want towork with and double-click it. The message flow is opened in the editor view.3. Right-click the node corresponding to the ESQL module that you want tomodify and click Open ESQL. The ESQL file is opened in the editor view. Themodule for this node is highlighted.4. Make the changes that you want in the module, by entering new statements(remember that you can use Content Assist, available from the Edit menu or, onsome systems, by pressing Ctrl+Space), changing existing statements byovertyping, or deleting statements using the Delete or backspace keys. Notethat, to get Content Assist to work with message references, you must set up aproject reference from the project containing the ESQL to the project containingthe message set. For information about setting up a project reference, seeProject references.5. You can change the name of the module that you are working with, byover-typing the current name with the new one. Remember that, if you do that,you must also change the node property ESQL Module to reflect the new nameto ensure that the correct ESQL code is deployed with the node.6. When you have finished working with this module, you can close the ESQLfile. Save the file before you close it to retain all your changes and validateyour ESQL.If you prefer, you can open the ESQL file directly by double-clicking it in theBroker Development view. You can select the module that you want to work withfrom the Outline view.The editor provides functions that you can use to help you modify your ESQLcode. These functions are described in ESQL editor.You can also modify the ESQL source by selecting Source →Format. This optionformats all selected lines of code (unless only partially selected, when they areignored), or, if no lines are selected, formats the entire file (correcting alignmentsand indentation).Adding comments to ESQLYou can add comments to and remove comments from your ESQL code:1. To change an existing line of code into a comment line, click Source →Comment.2. To change a comment line to a code line, click Source →Uncomment.Developing ESQL19
3. To create a new comment line, press Enter to create a new line and either typethe comment identifier -- or click Source →Comment. You can enter any textafter the identifier: everything you type is ignored by the ESQL editor.Saving an ESQL fileWhen you edit your ESQL file, you can save it both to preserve the additions andmodifications that you have made, and to force the editor to validate the content ofthe file.Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To save an ESQL file:1. Switch to the Broker Application Development perspective.2. Create an ESQL file, or open an existing ESQL file.3. Change the contents of the ESQL file.4. When you have finished working, save the file to retain all your changes byclicking File →Save filename.esql or File →Save All (the menu always showsthe current filename correctly).When you save the file, the validator is called by the editor to check that theESQL obeys all grammar and syntax rules (specified by the syntax diagramsand explanations in “ESQL reference” on page 159).You can request additional validation when you set ESQL preferences:a. Click Window →Preferences. The Preferences dialog is displayed.b. Expand the item for Broker Development on the left, expand ESQL, andclick Validation.c. Select the level of validation that you require for each category of error:1) Unresolved identifiers2) Message references do not match message definitions3) Database references do not match database schema4) Use of deprecated keywordsThe default level is Warning; you can change this value to Error or Ignore.Validating message definitions can affect response times in the editor,particularly if you have complicated ESQL that makes many references to acomplex message definition. You might choose to delay this validation. Callvalidation when you have finished developing the message flow and areabout to deploy it, to avoid runtime errors. For each error found, the editorwrites the code line number and the reason for the error; errors are createdas entries in the Problems view.5. If you double-click the error, the editor positions your cursor on the line inwhich it found that error. The line is also highlighted by the error iconinthe margin to the left.The editor might also find potential error situations, that it highlights aswarnings (with the warning icon); it also writes these warnings to theProblems view. For example, you might have included a BROKER SCHEMAstatement that references an invalid schema (namespace).Check your code, and make the corrections required by that statement orfunction.20ESQL
Save AsYou can save a copy of this ESQL file by using File →Save As.1. Click File →Save name As.2. Specify the message flow project in which you want to save a copy of the ESQLfile. The project name defaults to the current project. You can accept this name,or choose another name from the valid options that are displayed in the FileSave dialog.3. Specify the name for the new copy of the ESQL file. If you want to save thisESQL file in the same project, you must either give it another name, or confirmthat you want to overwrite the current copy (that is, copy the file to itself).If you want to save this ESQL file in another project, the project must exist (youcan only select from the list of existing projects). You can save the file with thesame or another name in another project.4. Click OK. The message flow is saved and the message flow editor validates itscontents. The editor provides a report of all errors that it finds in the Problemsview.Copying an ESQL fileYou might find it useful to copy an ESQL file as a starting point for a new ESQLfile that has similar function.Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To copy an ESQL file:1. Switch to the Broker Application Development perspective.2.In the Broker Development view, select the ESQL file(<message_flow_name>.esql) that you want to copy. Right-click the file and clickCopy from the menu.3. Right-click the broker schema within the message flow project to which youwant to copy the ESQL file and click Paste. You can copy the ESQL file to thesame broker schema within the same message flow project, or to a differentbroker schema within the same message flow project, or to a broker schema ina different message flow project.When you copy an ESQL file, the associated files (message flow, and mappingif present) are not automatically copied to the same target message flow project.If you want these files copied as well, you must do this explicitly following thisprocedure.If you want to use this ESQL file with another message flow, ensure that themodules within the ESQL file match the nodes that you have in the messageflow, and that the node properties are set correctly.You can also use File →Save As to copy an ESQL file. This is described in “Savingan ESQL file” on page 20.Renaming an ESQL fileYou can rename an ESQL file within the message flow project. You might want todo this, for example, if you have renamed the message flow that it is associatedwith.Developing ESQL21
Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To rename an ESQL file:1. Switch to the Broker Application Development perspective.2. In the Broker Development view, right-click the ESQL file that you want torename. Its default name is <message_flow_name>.esql. Click Rename or clickFile →Rename. If you have selected the ESQL file, you can press F2. TheRename Resource dialog is displayed.3. Enter the new name for the ESQL file. Click OK to complete the action, orCancel to cancel the request. If you click OK, the ESQL file is renamed.Moving an ESQL fileIf you move a message flow from one broker schema to another, or from oneproject to another, you might want to move all ESQL files that are associated withthat message flow.Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To move an ESQL file:1. Switch to the Broker Application Development perspective.2. Move the ESQL file in one of the following ways:v Drag the ESQL file that you want to move from its current location to abroker schema within the same or another message flow project.If the target location that you have chosen is not valid (for example, if anESQL file of this name exists in the broker schema), the invalid icon isdisplayed and the move is not completed.v Right-click the ESQL file and click Move, or click File →Move. The Movedialog is displayed.Select the project and the broker schema from the list of valid targets that isshown in the dialog.Click OK to complete the move, or Cancel to cancel the request.If you click OK, the ESQL file is moved to its new location.3. Check the Problems view for errors (indicated by the error icon) orwarnings (indicated by the warning icon) generated by the move.The errors in the Problems view include those errors caused by brokenreferences. When the move is completed, all references to this ESQL file arechecked. If you have moved the file within the same named broker schemawithin the same message flow project, all references are still valid. If you havemoved the file to another broker schema in the same or another message flowproject, the references are broken. If you have moved the file to the samenamed broker schema in another message flow project, the references might bebroken if the project references are not set correctly to recognize externalreferences in this file. These errors occur because resources are linked by a fullyqualified name.22ESQL
4. Double-click each error or warning to open the message flow that has the errorin the editor view, and highlight the node in error. You can now correct theerror.When you move an ESQL file, its associated files (for example, the message flowfile) are not automatically moved to the same target broker schema. You mustmove these files yourself.Changing ESQL preferencesYou can modify the way in which ESQL is displayed in the editor and validated bythe editor:v “Changing ESQL editor settings”v “Changing ESQL validation settings” on page 24Changing ESQL editor settingsWhen you open an ESQL file in the editor view, you can tailor the editorappearance by changing editor settings.1. To change ESQL editor settings:a. Switch to the Broker Application Development perspective.b. Click Window →Preferences. The Preferences dialog box opens.c. Expand the item for ESQL on the left and click ESQL Editor.d. Update the settings available for tab width and colors:v Click the General tab to change the displayed tab width within the ESQLeditor.v Click the Colors tab to change the color of the editor view background,and of the entities displayed in the editor view. These include commentsand keywords in your ESQL code.e. When you have completed your changes, click either Apply (to apply yourchanges and leave the Preferences dialog box open), or OK (to apply yourchanges and close the dialog box). Alternatively, to close the dialog box anddiscard your changes, click Cancel.f. To return the ESQL editor settings to the initial values, click RestoreDefaults. All values are reset to the original settings.If you change the editor settings when you have an editor session active, thechanges are implemented immediately. If you do not have an editor sessionopen, you see the changes when you next edit an ESQL file.2. To change font settings for the ESQL editor:a. Click Window →Preferences. The Preferences dialog box opens.b. Expand the item for Workbench on the left of the Preferences dialog box,and click Colors and Fonts.c. On the Colors and Fonts tab, expand Basic.d. Select a font or text color option and click Change. The Font dialog boxopens.e. When you have completed your changes, click either Apply (to apply yourchanges and leave the Preferences dialog box open) or OK (to apply yourchanges and close the dialog box). Alternatively, to close the dialog box anddiscard your changes, click Cancel.f. To return the ESQL editor settings to the initial values, click RestoreDefaults.Developing ESQL23
Changing ESQL validation settingsYou can specify the level of validation that the ESQL editor performs when yousave a .esql file. If the validation you have requested results in warnings, you candeploy a BAR file containing this message flow. However, if errors are reported,you cannot deploy the BAR file.To change ESQL validation settings:1. Switch to the Broker Application Development perspective.2. Click Window →Preferences. The Preferences dialog is displayed.3. Expand the item for ESQL on the left and click Validation.4. Update the settings for what is validated, and for what warnings or errors arereported. See ESQL editor for details of the settings and their values.5. When you have completed your changes, click Apply to close the Preferencesdialog, apply your changes and leave the Preferences dialog open. Click OK toapply your changes and close the dialog. Click Cancel to close the dialog anddiscard your changes.6. If you want to return your ESQL editor preferences to the initial values, clickRestore Defaults. All values are reset to the original settings.If you make changes to the validation settings, the changes are implementedimmediately for currently open edit sessions and for subsequent edit sessions.Deleting ESQL for a nodeIf you delete a node from a message flow, you can delete the ESQL module thatyou created to customize its function.Before you startTo complete this task, you must have completed the following task:v “Creating ESQL for a node” on page 16To delete ESQL code:1. Switch to the Broker Application Development perspective.2. Open the message flow that you want to work with by double-clicking it in theBroker Development view. The message flow is opened in the editor view.3. Select the node for which you want to delete the ESQL module, right-click andclick Open ESQL. The ESQL file is opened in the editor view, with the modulefor this node highlighted.4. Press the Delete or backspace key to delete the whole module.5. When you have finished working with this module, you can close the ESQLfile. Save the file before you close it to retain all your changes. Save alsovalidates your ESQL: see “Saving an ESQL file” on page 20.If you prefer, you can open the ESQL file directly by double-clicking it in theBroker Development view. The ESQL file is opened in the editor view. Select themodule that you want to delete from the Outline view and delete it as describedabove. You can also right-click on the module name in the Broker Developmentview (the modules in the ESQL file are visible if you expand the view of the file byclicking the + beside the file name) and click Delete.24ESQL
Deleting an ESQL fileIf you delete a message flow, or if you have deleted all the ESQL code in an ESQLfile, you can delete the ESQL file.Before you startTo complete this task, you must have completed the following task:v “Creating an ESQL file” on page 14To delete an ESQL file:1. Switch to the Broker Application Development perspective.2. Within the Broker Development view, right-click the ESQL file that you want todelete, and click Delete. A dialog is displayed that asks you to confirm thedeletion.You can also select the file in the Broker Development view, and click Edit →Delete. A dialog is displayed that asks you to confirm the deletion.3. Click Yes to delete the file, or No to cancel the delete request.If you maintain resources in a shared repository, a copy is retained in thatrepository. You can follow the instructions provided by the repository supplierto retrieve the file if required.If you are using the local file system or a shared file system to store yourresources, no copy of the file is retained. Be careful to select the correct filewhen you complete this task.Writing ESQLHow you can use ESQL to customize nodes.When you create a message flow, you include input nodes that receive themessages and, optionally, output nodes that send out new or updated messages. Ifrequired by the processing that must be performed on the message, you caninclude other nodes after the input node that complete the actions that yourapplications need.Some of the built-in nodes enable you to customize the processing that theyprovide. The Compute, Database, and Filter nodes require you to provide aminimum level of ESQL, and you can provide much more than the minimum tocontrol precisely the behavior of each node. This set of topics discusses ESQL andthe ways in which you can use it to customize these nodes.The DataDelete, DataInsert, DataUpdate, Extract, Mapping, and Warehouse nodesprovide a mapping interface with which you can customize their function. Theways in which you can use the mapping functions associated with these nodes aredescribed in developing message mappings, see Developing message mappings.ESQL provides a rich and flexible syntax for statements and functions that enableyou to check and manipulate message and database content. You can:v Read the contents of the input messagev Modify message content with data from databasesv Modify database content with data from messagesv Construct new output messages created from all, part, or none of the inputmessage (in the Compute node only)Developing ESQL25
The following topics provide more information about these and other tasks thatyou can perform with ESQL. Unless otherwise stated, these guidelines apply tomessages in all message domains except the BLOB domain, for which you canimplement a limited set of actions.v “Tailoring ESQL code for different node types” on page 27v “Manipulating message body content” on page 28v “Manipulating other parts of the message tree” on page 48v “Transforming from one data type to another” on page 60v “Adding keywords to ESQL files” on page 67v “Interaction with databases using ESQL” on page 67v “Coding ESQL to handle errors” on page 79v “Accessing broker properties from ESQL” on page 154v “Configuring a message flow at deployment time with user-defined properties”on page 154The following topics provide additional information specific to the parser that youhave specified for the input message:v “Manipulating messages in the MRM domain” on page 132v “Manipulating messages in the XML domain” on page 132v “Manipulating messages in the XMLNS domain” on page 122v “Manipulating messages in the XMLNSC domain” on page 109v “Manipulating messages in the JMS domains” on page 148v “Manipulating messages in the IDOC domain” on page 149v “Manipulating messages in the MIME domain” on page 150v “Manipulating messages in the BLOB domain” on page 152ESQL examplesMost of the examples included in the topics listed previously showparser-independent ESQL. If examples include a reference to MRM, they assumethat you have modeled the message in the MRM and that you have set the namesof the MRM objects to be identical to the names of the corresponding tags orattributes in the XML source message. Some examples are also shown for the XMLdomain. Unless stated otherwise, the principals illustrated are the same for allmessage domains. For domain-specific information, use the appropriate link in theprevious list.Most of the topics that include example ESQL use the ESQL sample message,Invoice, as the input message to the logic. This message is provided in XML sourceformat (with tags and attributes), see “Example message” on page 385. Theexample message is shown in the following diagram.The topics specific to the MRM domain use the message that is created in thefollowing sample:v Video RentalYou can view samples information only when you use the information center thatis integrated with the Message Broker Toolkit or the online information center.A few other input messages are used to show ESQL that provides function onmessages with a structure or content that is not included in the Invoice or Videosamples. Where this occurs, the input message is included in the topic that refersto it.26ESQL
Tailoring ESQL code for different node typesWhen you code ESQL to configure Compute, Database, and Filter node behavior,be aware of the limitations of each type of node.Compute nodeYou can configure the Compute node to do any of the followingoperations:v Update data in a database.v Insert data into a database.v Delete data from a database.v Update the environment tree.v Update the local environment tree.v Create one or more output messages, with none, some, or all the contentof the input message, and propagate these new messages to the nextnode in the message flow.To propagate the input LocalEnvironment to the outputLocalEnvironment, remember to set the Compute node propertyCompute mode to an appropriate value. The Environment is alwayspropagated in the output message.PaymentPurchasesInvoiceDateTillNumberCashierInvoiceTimeInvoiceNoDirectMailStoreRecordErrorCustomerAddressAddressAddressPostCodeFirstNameTitlePhoneHomeBillingLastNameDOBPhoneWorkCardTypeCardNameExpiresValidCardNoInvoiceItemItemItemTitlePublishDateQuantityAuthorPublisherUnitPriceISBNDeveloping ESQL27
Database nodeYou can configure the Database node to do any of the followingoperations:v Update data in a database.v Insert data into a database.v Delete data from a database.v Update the environment tree.v Update the local environment tree.v Propagate the input message to the next node in the message flow.Filter nodeYou can configure the Filter node to do any of the following operations:v Update data in a database.v Insert data into a database.v Delete data from a database.v Update the environment tree.v Update the local environment tree.v Propagate the input message to the next node in the message flow (theterminal through which the message is propagated depends on theresult of the filter expression).View the remaining tasks in this section to find the details of how you can performthese operations.Manipulating message body contentThe message body is always the last child of root, and is identified by its parsername, for example XML or MRM. You can refer to, modify, and create messagebody data.The following topics describe how you can refer to, modify, and create messagebody data. The information provided here is domain independent.v “Referencing field types”v “Accessing elements in the message body” on page 29v “Accessing known multiple occurrences of an element” on page 33v “Accessing unknown multiple occurrences of an element” on page 34v “Using anonymous field references” on page 35v “Creating dynamic field references” on page 36v “Creating new fields” on page 37v “Generating multiple output messages” on page 39v “Using numeric operators with datetime values” on page 40v “Calculating a time interval” on page 41v “Selecting a subfield from a larger field” on page 42v “Copying repeating fields” on page 43v “Manipulating repeating fields in a message tree” on page 47Referencing field typesSome message parsers have complex models in which it is not enough to identify afield simply by its name and an array subscript. In these cases, you associate anoptional field type with an element of data in the tree format.28ESQL
Each element within the parsed tree can be one of three types:Name elementA name element has a string, which is the name of the element, associatedwith it. An example of a name element is XMLElement, described in XMLelement.Value elementA value element has a value associated with it. An example of a valueelement is XMLContent, described in XML content.Name-value elementA name-value element is an optimization of the case where a nameelement contains only a value element and nothing else. The elementcontains both a name and a value. An example of a name-value element isXMLAttribute, described in XML attribute.Accessing elements in the message bodyWhen you want to access the contents of a message, for reading or writing, use thestructure and arrangement of the elements in the tree that is created by the parserfrom the input bit stream.Follow the relevant parent and child relationships from the top of the treedownwards, until you reach the required element.v If you are referring to the input message tree to interrogate its content in aCompute node, use correlation name InputBody followed by the path to theelement to which you are referring. InputBody is equivalent to InputRootfollowed by the parser name (for example, InputRoot.MRM), which you can use ifyou prefer.v If you are referring to the output message tree to set or modify its content in theCompute node, use correlation name OutputRoot followed by the parser name(for example, OutputRoot.MRM).v If you are referring to the input message to interrogate its contents in a Databaseor Filter node, use correlation name Body to refer to the start of the message.Body is equivalent to Root followed by the parser name (for example,Root.XMLNS), which you can use if you prefer.You must use these different correlation names because there is only onemessage to which to refer in a Database or Filter node; you cannot create anoutput message in these nodes. Use a Compute node to create an outputmessage.When you construct field references, the names that you use must be valid ESQLidentifiers that conform to ESQL rules. If you enclose an item in double quotationmarks, ESQL interprets it as an identifier. If you enclose an item in single quotationmarks, ESQL interprets it as a character literal. You must enclose all strings(character strings, byte strings, or binary (bit) strings) in quotation marks, asshown in the following examples. To include a single or double quotation markwithin a string, include two consecutive single or double quotation marks.Important: For a full description of field reference syntax, see “ESQL fieldreference overview” on page 174.For more information about ESQL data types, see “ESQL data types in messageflows” on page 160.Developing ESQL29
Assume that you have created a message flow that handles the message Invoice,shown in the figure in “Writing ESQL” on page 25. If, for example, you want tointerrogate the element CardType from within a Compute node, use the followingstatement:IF InputBody.Invoice.Payment.CardType='Visa' THENDO;-- more ESQL --END IF;If you want to make the same test in a Database or Filter node (where thereference is to the single input message), code:IF Body.Invoice.Payment.CardType='Visa' THENDO;-- more ESQL --END IF;If you want to copy an element from an input XML message to an output messagein the Compute node without changing it, use the following ESQL:SET OutputRoot.XMLNS.Invoice.Customer.FirstName =InputBody.Invoice.Customer.FirstName;If you want to copy an element from an input XML message to an output messageand update it, for example by folding to uppercase or by calculating a new value,code:SET OutputRoot.XMLNS.Invoice.Customer.FirstName =UPPER(InputBody.Invoice.Customer.FirstName);SET OutputRoot.XMLNS.Invoice.InvoiceNo = InputBody.Invoice.InvoiceNo + 1000;If you want to set a STRING element to a constant value, code:SET OutputRoot.XMLNS.Invoice.Customer.Title = 'Mr';You can also use the equivalent statement:SET OutputRoot.XMLNS.Invoice.Customer.Title VALUE = 'Mr';If you want to update an INTEGER or DECIMAL, for example the elementTillNumber, with the value 26, use the following assignment (valid in the Computenode only):The integer data type stores numbers using the 64-bit twos complement form,allowing numbers in the range -9223372036854775808 to 9223372036854775807. Youcan specify hexadecimal notation for integers as well as normal integer literalformat. The hexadecimal letters A to F can be written in uppercase or lowercase, ascan the X after the initial zero, which is required. The following example producesthe same result as the example shown earlier:The following examples show SET statements for element types that do not appearin the example Invoice message.To set a FLOAT element to a non-integer value, code:SET OutputRoot.MRM.Invoice.TillNumber=26;SET OutputRoot.MRM.Invoice.TillNumber= 0x1A;SET OutputRoot.MRM.FloatElement1 = 1.2345e2;30ESQL
To set a BINARY element to a constant value, code:For BINARY values, you must use an initial character X (uppercase or lowercase)and enclose the hexadecimal characters (also uppercase or lowercase) in singlequotation marks, as shown.To set a BOOLEAN element to a constant value (the value 1 equates to true, 0equates to false), code:orYou can use the SELECT statement to filter records from an input message withoutreformatting the records, and without any knowledge of the complete format ofeach record. Consider the following example:This code writes all records from the input Invoice message to the output messageif the WHERE condition (LastName = Smith) is met. All records that do not meetthe condition are not copied from input message to output message. I is used as analias for the correlation name InputRoot.XMLNS.Invoice[].The declared variable CurrentCustomer is initialized on the DECLARE statement:this option is the most efficient way of declaring a variable for which the initialvalue is known.You can use this alias technique with other SELECT constructs. For example, if youwant to select all the records of the input Invoice message, and create an additionalrecord:You could also include an AS clause to place records in a subfolder in the messagetree:If you are querying or setting elements that contain, or might contain, null values,be aware of the following considerations:SET OutputRoot.MRM.BinaryElement1 = X'F1F1';SET OutputRoot.MRM.BooleanElement1 = true;SET OutputRoot.MRM.BooleanElement1 = 1;-- Declare local variableDECLARE CurrentCustomer CHAR 'Smith';-- Loop through the input messageSET OutputRoot.XMLNS.Invoice[] =(SELECT I FROM InputRoot.XMLNS.Invoice[] AS IWHERE I.Customer.LastName = CurrentCustomer);-- Loop through the input messageSET OutputRoot.XMLNS.Invoice[] =(SELECT I, 'Customer' || I.Customer.LastName AS ExtraFieldFROM InputRoot.XMLNS.Invoice[] AS I);-- Loop through the input messageSET OutputRoot.XMLNS.Invoice[] =(SELECT I AS OrderFROM InputRoot.XMLNS.Invoice[] AS I);Developing ESQL31
Querying null valuesWhen you compare an element to the ESQL keyword NULL, this testswhether the element is present in the logical tree that has been createdfrom the input message by the parser.For example, you can check if an invoice number is included in the currentInvoice message with the following statement:You can also use an ESQL reference, as shown in the following example:For more information about declaring and using references, see “Creatingdynamic field references” on page 36. For a description of the LASTMOVEand FIELDVALUE functions, see “LASTMOVE function” on page 325 and“FIELDTYPE function” on page 321.If the message is in the MRM domain, there are additional considerationsfor querying null elements that depend on the physical format. For furtherdetails, see “Querying null values in a message in the MRM domain” onpage 141.Setting null valuesYou can use two statements to set null values:1. If you set the element to NULL by using the following statement, theelement is deleted from the message tree:If the message is in the MRM domain, there are additionalconsiderations for null values that depend on the physical format. Forfurther details, see “Setting null values in a message in the MRMdomain” on page 142.This technique is called implicit null processing.2. If you set the value of this element to NULL as follows:the element is not deleted from the message tree. Instead, a specialvalue of NULL is assigned to the element.IF InputRoot.XMLNS.Invoice.InvoiceNo IS NULL THENDO;-- more ESQL --END IF;DECLARE cursor REFERENCE TO InputRoot.MRM.InvoiceNo;IF LASTMOVE(cursor) = FALSE THENSET OutputRoot.MRM.Analysis = 'InvoiceNo does not exist in logical tree';ELSEIF FIELDVALUE(cursor) IS NULL THENSET OutputRoot.MRM.Analysis ='InvoiceNo does exist in logical tree but is defined as an MRM NULL value';ELSESET OutputRoot.MRM.Analysis = 'InvoiceNo does exist and has a value';END IF;SET OutputRoot.XMLNS.Invoice.Customer.Title = NULL;SET OutputRoot.XMLNS.Invoice.Customer.Title VALUE = NULL;SET OutputRoot.XMLNS.Invoice.Customer.Title = NULL;32ESQL
If the message is in the MRM domain, the content of the output bitstream depends on the settings of the physical format null handlingproperties. For further details, see “Setting null values in a message inthe MRM domain” on page 142.This technique is called explicit null processing.If you set an MRM complex element or an XML, XMLNS, or JMS parentelement to NULL without using the VALUE keyword, that element and allits children are deleted from the logical tree.Accessing known multiple occurrences of an elementWhen you refer to or create the content of messages, it is very likely that the datacontains repeating fields. If you know how many instances there are of a repeatingfield, and you want to access a specific instance of such a field, you can use anarray index as part of a field reference.For example, you might want to filter on the first line of an address, to expeditethe delivery of an order. Three instances of the element Billling.Address are alwayspresent in the sample message. To test the first line, write an expression such as:The array index [1] indicates that it is the first instance of the repeating field thatyou are interested in (array indices start at 1). An array index such as this can beused at any point in a field reference, so you could, for example, filter on thefollowing test:You can refer to the last instance of a repeating field using the special [<] arrayindex, and to instances relative to the last (for example, the second to last) asfollows:v Field[<] indicates the last element.v Field[<1] indicates the last element.v Field[<2] indicates the last but one element (the penultimate element).You can also use the array index [>] to represent the first element, and elementsrelative to the first element in a similar way.v Field[>] indicates the first element. This is equivalent to Field[1].The following examples refer to the Invoice message using these indexes:IF Body.Invoice.Customer.Billing.Address[1] = 'Patent Office' THENDO;-- more ESQL --END IF;IF Body.Invoice."Item"[1].Quantity> 2 THENDO;-- more ESQL --END IF;IF Body.Invoice.Customer.Billing.Address[<] = 'Hampshire' THENDO;-- more ESQL --END IF;IF Body.Invoice.Customer.Billing.Address[<2 ] = 'Southampton' THENDO;-- more ESQL --END IF;Developing ESQL33
You can also use these special indexes for elements that repeat an unknownnumber of times.Deleting repeating fields:If you pass a message with several repeats of an element through a message flowand you want to delete some of the repeats, be aware that the numbering of therepeats is reordered after each delete. For example, if you have a message with fiverepeats of a particular element, and in the message flow you have the followingESQL:You might expect elements one and four to be deleted. However, because repeatingelements are stored on a stack, when you delete one, the one above it takes itsplace. This means that, in the above example, elements one and five are deleted. Toavoid this problem, delete in reverse order, that is, delete element four first, thendelete element one.Accessing unknown multiple occurrences of an elementTo access repeating fields in a message, you must use a construct that can iterateover all instances of a repeating field.You are likely to deal with messages that contain repeating fields with anunknown number of repeats (such as the Item field in “Example message” on page385).To write a filter that takes into account all instances of the Item field, you need touse a construct that can iterate over all instances of a repeating field. Thequantified predicate allows you to execute a predicate against all instances of arepeating field, and collate the results.For example, you might want to verify that none of the items that are beingordered has a quantity greater than 50. To do this you could write:With the quantified predicate, the first thing to note is the brackets [] on the end ofthe field reference after FOR ALL. These tell you that you are iterating over allinstances of the Item field.In some cases, this syntax appears unnecessary because you can get thatinformation from the context, but it is done for consistency with other pieces ofsyntax.The AS clause associates the name I with the current instance of the repeatingfield. This is similar to the concept of iterator classes used in some object orientedlanguages such as C++. The expression in parentheses is a predicate that isevaluated for each instance of the Item field.A description of this example is:Iterate over all instances of the field Item inside Body.Invoice. For each iteration:1. Bind the name I to the current instance of Item.SET OutputRoot.MRM.e_PersonName[1] = NULL;SET OutputRoot.MRM.e_PersonName[4] = NULL;FOR ALL Body.Invoice.Purchases."Item"[]AS I (I.Quantity <= 50)34ESQL
2. Evaluate the predicate I.Quantity <= 50. If the predicate:v Evaluates to TRUE for all instances of Item, return TRUE.v Is FALSE for any instance of Item, return FALSE.v For a mixture of TRUE and UNKNOWN, return UNKNOWN.The above is a description of how the predicate is evaluated if you use the ALLkeyword. An alternative is to specify SOME, or ANY, which are equivalent. In thiscase the quantified predicate returns TRUE if the sub-predicate returns TRUE forany instance of the repeating field. Only if the sub-predicate returns FALSE for allinstances of the repeating field does the quantified predicate return FALSE. If amixture of FALSE and UNKNOWN values are returned from the sub-predicate, anoverall value of UNKNOWN is returned.In the following filter expression:the sub-predicate evaluates to TRUE. However this next expression returns FALSE:because the C Primer is not included on this invoice. If some of the items in theinvoice do not include a book title field, the sub-predicate returns UNKNOWN,and the quantified predicate returns the value UNKNOWN.To deal with the possibility of null values appearing, write this filter with anexplicit check on the existence of the field, as follows:The predicate IS NOT NULL ensures that, if an Item field does not contain a Book,a FALSE value is returned from the sub-predicate.You can also manipulate arbitrary repeats of fields within a message by using aSELECT expression, as described in “Referencing columns in a database” on page68.You can refer to the first and last instances of a repeating field using the [>] and[<] array indexes, and to instances relative to the first and last, even if you do notknow how many instances there are. These indexes are described in “Accessingknown multiple occurrences of an element” on page 33.Alternatively, you can use the CARDINALITY function to determine how manyinstances of a repeating field there are. For example:Using anonymous field referencesYou can refer to the array of all children of a particular element by using a pathelement of *.For example:FOR ANY Body.Invoice.Purchases."Item"[]AS I (I.Title = 'The XML Companion')FOR ANY Body.Invoice.Purchases."Item"[]AS I (I.Title = 'C Primer')FOR ANY Body.Invoice.Purchases."Item"[]AS I (I.Book IS NOT NULL AND I.Book.Title = 'C Primer')DECLARE I INTEGER CARDINALITY(Body.Invoice.Purchases."Item"[])Developing ESQL35
is a path that identifies the array of all children of InputRoot. This is often used inconjunction with an array subscript to refer to a particular child of an entity byposition, rather than by name. For example:InputRoot.*[<]Refers to the last child of the root of the input message, that is, the body ofthe message.InputRoot.*[1]Refers to the first child of the root of the input message, the messageproperties.You might want to find out the name of an element that has been identified with apath of this kind. To do this, use the FIELDNAME function, which is described in“FIELDNAME function” on page 320.Creating dynamic field referencesYou can use a variable of type REFERENCE as a dynamic reference to navigate amessage tree. This acts in a similar way to a message cursor or a variable pointer.It is generally simpler and more efficient to use reference variables in preference toarray indexes when you access repeating structures. Reference variables areaccepted everywhere. Field references are accepted and come with a set ofstatements and functions to allow detailed manipulation of message trees.You must declare a dynamic reference before you can use it. A dynamic referenceis declared and initialized in a single statement. The following example shows howto create and use a reference.This example declares a dynamic reference, myref, which points to the first item inthe array within Purchases. The value in the first item is incremented by one, andthe pointer (dynamic reference) is moved to the next item. Once again the itemvalue is incremented by one. This process continues until the pointer movesoutside the scope of the message array (all the items in this array have beenprocessed) and the LASTMOVE function returns FALSE.The following examples show further examples.InputRoot.*[]-- Declare the dynamic referenceDECLARE myref REFERENCE TO OutputRoot.XMLNS.Invoice.Purchases.Item[1];--Continue processing for each item in the arrayWHILE LASTMOVE(myref)=TRUEDO-- Add 1 to each item in the arraySET myref = myref + 1;-- Move the dynamic reference to the next item in the arrayMOVE myref NEXTSIBLING;END WHILE;DECLARE ref1 REFERENCE TO InputBody.Invoice.Purchases.Item[1];DECLARE ref2 REFERENCE TOInputBody.Invoice.Purchases.NonExistentField;DECLARE scalar1 CHARACTER;DECLARE ref3 REFERENCE TO scalar1;36ESQL
In the second example, ref2 is set to point to InputBody because the specified fielddoes not exist.With the exception of the MOVE statement, which changes the position of thedynamic reference, you can use a dynamic reference anywhere that you can use astatic reference. The value of the dynamic reference in any expression or statementis the value of the field or variable to which it currently points. For example, usingthe message in “Example message” on page 385, the value ofInvoice.Customer.FirstName is Andrew. If the dynamic reference myref is set topoint at the FirstName field as follows:the value of myref is Andrew. You can extend this dynamic reference as follows:This changes the address in the example to Oaklands Hursley Village HampshireSO213JR.The position of a dynamic reference remains fixed even if a tree is modified. Toillustrate this point the steps that follow use the message in “Example message” onpage 385 as their input message and create a modified version of this message asan output message:1. Copy the input message to the output message.2. To modify the output message, first declare a dynamic reference ref1 thatpoints at the first item, The XML Companion.The dynamic reference is now equivalent to the static referenceOutputRoot.XMLNS.Invoice.Purchases.Item[1].3. Use a create statement to insert a new first item for this purchase.The dynamic reference is now equivalent to the static referenceOutputRoot.XMLNS.Invoice.Purchases.Item[2].Creating new fieldsYou can use a Compute node to create a new output message by adding newfields to an existing input message.This topic provides example ESQL code for a Compute node that creates a newoutput message based on the input message, to which are added a number ofadditional fields.The input message received by the Compute node within the message flow is anXML message, and has the following content:<TestCase description="This is my TestCase"><Identifier>ES03B305_T1</Identifier><Sport>Football</Sport><Date>01/02/2000</Date><Type>LEAGUE</Type></TestCase>DECLARE myref REFERENCE TO Invoice.Customer;SET myref.Billing.Address[1] = 'Oaklands';DECLARE ref1 REFERENCE TOOutputRoot.XMLNS.Invoice.Purchases.Item[1];CREATE PREVIOUSSIBLING OF ref1 VALUES 'Item';Developing ESQL37
The Compute node is configured and an ESQL module is created that includes thefollowing ESQL. The following code copies the headers from the input message tothe new output message, then creates the entire content of the output messagebody.-- copy headersDECLARE i INTEGER 1;DECLARE numHeaders INTEGER CARDINALITY(InputRoot.*[]);WHILE i < numHeaders DOSET OutputRoot.*[i] = InputRoot.*[i];SET i = i + 1;END WHILE;CREATE FIELD OutputRoot.XMLNS.TestCase.description TYPE NameValue VALUE 'This is my TestCase';CREATE FIRSTCHILD OF OutputRoot.XMLNS.TestCase Domain('XMLNS') NAME 'Identifier'VALUE InputRoot.XMLNS.TestCase.Identifier;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase Domain('XMLNS') NAME 'Sport'VALUE InputRoot.XMLNS.TestCase.Sport;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase Domain('XMLNS') NAME 'Date'VALUE InputRoot.XMLNS.TestCase.Date;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase Domain('XMLNS') NAME 'Type'VALUE InputRoot.XMLNS.TestCase.Type;CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Number TYPE NameValueVALUE 'Premiership';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[1].Number TYPE NameValue VALUE'1';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[1].Home TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[1].Home NAME 'Team'VALUE 'Liverpool' ;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[1].Home NAME 'Score'VALUE '4';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[1].Away TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[1].Away NAME 'Team'VALUE 'Everton';CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[1].Away NAME 'Score'VALUE '0';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[2].Number TYPE NameValue VALUE '2';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[2].Home TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[2].Home NAME 'Team'VALUE 'Manchester United';CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[2].Home NAME 'Score'VALUE '2';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[1].Result[2].Away TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[2].Away NAME 'Team'VALUE 'Arsenal';CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[1].Result[2].Away NAME 'Score'VALUE '3';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[2].Number TYPE NameValueVALUE '2';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[2].Result[1].Number TYPE NameValueVALUE'1';CREATE FIELD OutputRoot.XMLNS.TestCase.Division[2].Result[1].Home TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[2].Result[1].Home NAME 'Team'VALUE 'Port Vale';CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[2].Result[1].Home NAME 'Score'VALUE '9' ;CREATE FIELD OutputRoot.XMLNS.TestCase.Division[2].Result[1].Away TYPE Name;CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[2].Result[1].Away NAME 'Team'VALUE 'Brentford';CREATE LASTCHILD OF OutputRoot.XMLNS.TestCase.Division[2].Result[1].Away NAME 'Score'VALUE '5';The output message that results from the ESQL shown above has the followingstructure and content:38ESQL
<TestCase description="This is my TestCase"><Identifier>ES03B305_T1</Identifier><Sport>Football</Sport><Date>01/02/2000</Date><Type>LEAGUE</Type><Division Number="Premiership"><Result Number="1"><Home><Team>Liverpool</Team><Score>4</Score></Home><Away><Team>Everton</Team><Score>0</Score></Away></Result><Result Number="2"><Home><Team>Manchester United</Team><Score>2</Score></Home><Away><Team>Arsenal</Team><Score>3</Score></Away></Result></Division><Division Number="2"><Result Number="1"><Home><Team>Port Vale</Team><Score>9</Score></Home><Away><Team>Brentford</Team><Score>5</Score></Away></Result></Division></TestCase>Generating multiple output messagesYou can use the PROPAGATE statement to generate multiple output messages inthe Compute node. The output messages that you generate can have the same ordifferent content. You can also direct output messages to any of the four alternateoutput terminals of the Compute node, or to a Label node.For example, to create three copies of the input message received by the Computenode, and send one to the standard Out terminal of the Compute node, one to thefirst alternate Out1 terminal of the Compute node, and one to the Label nodeThirdCopy, code the following ESQL:In the above example, the content of OutputRoot is reset before each PROPAGATE,because by default the node clears the output message buffer and reclaims thememory when the PROPAGATE statement completes. An alternative method is toinstruct the node not to clear the output message on the first two PROPAGATEstatements, so that the message is available for routing to the next destination. TheSET OutputRoot = InputRoot;PROPAGATE;SET OutputRoot = InputRoot;PROPAGATE TO TERMINAL 'out1';SET OutputRoot = InputRoot;PROPAGATE TO LABEL 'ThirdCopy';Developing ESQL39
code to achieve this result is:If you do not initialize the output buffer, an empty message is generated, and themessage flow detects an error and throws an exception.Also ensure that you copy all required message headers to the output messagebuffer for each output message that you propagate.If you want to modify the output message content before propagating eachmessage, code the appropriate ESQL to make the changes that you want beforeyou code the PROPAGATE statement.If you set up the contents of the last output message that you want to generate,and propagate it as the final action of the Compute node, you do not have toinclude the final PROPAGATE statement. The default action of the Compute nodeis to propagate the contents of the output buffer when it terminates. This isimplemented by the RETURN TRUE statement, included as the final statement inthe module skeleton.For example, to generate three copies of the input message, and not perform anyfurther action, include this code immediately before the RETURN TRUE statement:Alternatively, you can modify the default behavior of the node by changingRETURN TRUE to RETURN FALSE:Three output messages are generated by the three PROPAGATE statements. Thefinal RETURN FALSE statement causes the node to terminate but not propagate afinal output message. Note that the final PROPAGATE statement does not includethe DELETE NONE clause, because the node must release the memory at thisstage.Using numeric operators with datetime valuesThe following examples show the ESQL that you can code to manipulate datetimevalues with numeric operators.Adding an interval to a datetime valueThe simplest operation that you can perform is to add an interval to, orsubtract an interval from, a datetime value. For example, you could writethe following expressions:SET OutputRoot = InputRoot;PROPAGATE DELETE NONE;SET OutputRoot = InputRoot;PROPAGATE TO TERMINAL 'out1' DELETE NONE;SET OutputRoot = InputRoot;PROPAGATE TO LABEL 'ThirdCopy';SET OutputRoot = InputRoot;PROPAGATE DELETE NONE;PROPAGATE DELETE NONE;SET OutputRoot = InputRoot;PROPAGATE DELETE NONE;PROPAGATE DELETE NONE;PROPAGATE;RETURN FALSE;40ESQL
Adding or subtracting two intervalsYou can combine two interval values by using addition or subtraction. Thetwo interval values must be of compatible types. It is not valid to add ayear-month interval to a day-second interval as shown in the followingexample:The interval qualifier of the resultant interval is sufficient to encompass allthe fields that are present in the two operand intervals. For example:results in an interval with qualifier DAY TO SECOND, because both dayand second fields are present in at least one of the operand values.Subtracting two datetime valuesYou can subtract two datetime values to return an interval. You mustinclude an interval qualifier in the expression to indicate what precisionthe result should be returned in. For example:returns the number of days since the 4th July 1776, whereas:returns the age of the day in minutes and seconds.Scaling intervalsYou can multiply or divide an interval value by an integer factor:Calculating a time intervalYou can use ESQL to calculate the time interval between two events, and to set atimer to be triggered after a specified interval.This ESQL example calculates the time interval between an input WebSphere MQmessage being put on the input queue, and the time that it is processed in thecurrent Compute node.DATE '2000-03-29' + INTERVAL '1' MONTHTIMESTAMP '1999-12-31 23:59:59' + INTERVAL '1' SECONDThe following example shows how to calculate a retirement date by adding the retirementage to the birth date.DECLARE retAge CHARACTER '65';DECLARE birthDate DATE DATE '1953-06-01';SET OutputRoot.XML.Test.retirementDate = birthDate + CAST(retAge AS INTERVAL YEAR);The repetition of the word DATE in the above example is intentional. The first occurrence ofDATE specifies the data type of the declared variable, birthDate. The second occurrenceinitializes the same variable with the constant character string that is enclosed in singlequotation marks as a DATE.INTERVAL '1-06' YEAR TO MONTH + INTERVAL '20' DAYINTERVAL '2 01' DAY TO HOUR + INTERVAL '123:59' MINUTE TO SECOND(CURRENT_DATE - DATE '1776-07-04') DAY(CURRENT_TIME - TIME '00:00:00') MINUTE TO SECONDINTERVAL '2:30' MINUTE TO SECOND / 4Developing ESQL41
(When you make a call to a CURRENT_ datetime function, the value that isreturned is identical to the value returned to another call in the same node. Thisensures that you can use the function consistently within a single node.)CALL CopyMessageHeaders();Declare PutTime INTERVAL;SET PutTime = (CURRENT_GMTTIME - InputRoot.MQMD.PutTime) MINUTE TO SECOND;SET OutputRoot.XMLNS.Test.PutTime = PutTime;The output message has the format (although actual values vary):<Test><PutTime>INTERVAL &apos;1:21.862&apos; MINUTE TO SECOND</PutTime></Test>The following code snippet sets a timer, to be triggered after a specified intervalfrom the start of processing, in order to check that processing has completed. Ifprocessing has not completed within the elapsed time, the firing of the timermight, for example, trigger some recovery processing.The StartTime field of the timeout request message is set to the current time plusthe allowed delay period, which is defined by a user-defined property on the flow.(The user-defined property has been set to a string of the form "HH:MM:SS" by theadministrator.)DECLARE StartDelyIntervalStr EXTERNAL CHARACTER '01:15:05';CREATE PROCEDURE ValidateTimeoutRequest() BEGIN-- Set the timeout periodDECLARE timeoutStartTimeRef REFERENCE TOOutputRoot.XMLNSC.Envelope.Header.TimeoutRequest.StartTime;IF LASTMOVE(timeoutStartTimeRef)THEN-- Already setELSE-- Set it from the UDP StartDelyIntervalStrDECLARE startAtTime TIME CURRENT_TIME+ CAST(StartDelyIntervalStr AS INTERVAL HOUR TO SECOND);-- Convert "TIME 'hh.mm.ss.fff'" to hh.mm.ss format-- needed in StartTime fieldDECLARE startAtTimeStr CHAR;SET startAtTimeStr = startAtTime;SET startAtTimeStr = SUBSTRING(startAtTimeStr FROM 7 FOR8);SET OutputRoot.XMLNSC.Envelope.Header.TimeoutRequest.StartTime= startAtTimeStr;END IF;END;Selecting a subfield from a larger fieldYou might have a message flow that processes a message containing delimitedsubfields. You can code ESQL to extract a subfield from the surrounding content ifyou know the delimiters of the subfield.If you create a function that performs this task, or a similar one, you can invoke itboth from ESQL modules (for Compute, Database, and Filter nodes) and frommapping files (used by DataDelete, DataInsert, DataUpdate, Extract, Mapping, andWarehouse nodes).The following function example extracts a particular subfield of a message that isdelimited by a specific character.42ESQL
CREATE FUNCTION SelectSubField(SourceString CHAR, Delimiter CHAR, TargetStringPosition INT)RETURNS CHAR-- This function returns a substring at parameter position TargetStringPosition within the-- passed parameter SourceString.An example of use might be:-- SelectSubField(MySourceField,' ',2) which will select the second subfield from the-- field MySourceField delimited by a blank.If MySourceField has the value-- "First Second Third" the function will return the value "Second"BEGINDECLARE DelimiterPosition INT;DECLARE CurrentFieldPosition INT 1;DECLARE StartNewString INT 1;DECLARE WorkingSource CHAR SourceString;SET DelimiterPosition = POSITION(Delimiter IN SourceString);WHILE CurrentFieldPosition < TargetStringPositionDOIF DelimiterPosition = 0THEN-- DelimiterPosition will be 0 if the delimiter is not found-- exit the loopSET CurrentFieldPosition = TargetStringPosition;ELSESET StartNewString = DelimiterPosition + 1;SET WorkingSource = SUBSTRING(WorkingSource FROM StartNewString);SET DelimiterPosition = POSITION(Delimiter IN WorkingSource);SET CurrentFieldPosition = CurrentFieldPosition + 1;END IF;END WHILE;IF DelimiterPosition> 0 THEN-- Remove anything following the delimiter from the stringSET WorkingSource = SUBSTRING(WorkingSource FROM 1 FOR DelimiterPosition);SET WorkingSource = TRIM(TRAILING Delimiter FROM WorkingSource);ENDIF;RETURN WorkingSource;END;Copying repeating fieldsYou can configure a node with ESQL to copy repeating fields in several ways.Consider an input XML message that contains a repeating structure:...<Field_top><field1></field1><field1></field1><field1></field1><field1></field1><field1></field1></Field_top>.....You cannot copy this whole structure field with the following statement:SET OutputRoot.XMLNS.Output_top.Outfield1 = InputRoot.XMLNS.Field_top.field1;That statement copies only the first repeat, and therefore produces the same resultas this statement:SET OutputRoot.XMLNS.Output_top.Outfield1[1] = InputRoot.XMLNS.Field_top.field1[1];You can copy the fields within a loop, controlling the iterations with theCARDINALITY of the input field:Developing ESQL43
SET I = 1;SET J = CARDINALITY(InputRoot.XMLNS.Field_top.field1[]);WHILEI <= J DOSET OutputRoot.XMLNS.Output_top.Outfield1[I] = InputRoot.XMLNS.Field_top.field1[I];SET I = I + 1;END WHILE;This might be appropriate if you want to modify each field in the output messageas you copy it from the input field (for example, add a number to it, or fold itscontents to uppercase), or after it has been copied. If the output message alreadycontained more Field1 fields than existed in the input message, the surplus fieldswould not be modified by the loop and would remain in the output message.The following single statement copies the iterations of the input fields to theoutput fields, and deletes any surplus fields in the output message.SET OutputRoot.XMLNS.Output_top.Outfield1.[] = InputRoot.XMLNS.Field_top.field1[];The following example shows how you can rename the elements when you copythem into the output tree. This statement does not copy across the source elementname, therefore each field1 element becomes a Target element.SET OutputRoot.XMLNS.Output_top.Outfield1.Target[] =(SELECT I FROM InputRoot.XMLNS.Field_top.field1[] AS I );The next example shows a different way to do the same operation; it produces thesame end result.SET OutputRoot.XMLNS.Output_top.Outfield2.Target[]= InputRoot.XMLNS.Field_top.field1[];The following example copies across the source element name. Each field1element is retained as a field1 element under the Target element.SET OutputRoot.XMLNS.Output_top.Outfield3.Target.[]= InputRoot.XMLNS.Field_top.field1[];This example is an alternative way to achieve the same result, with field1elements created under the Target element.SET OutputRoot.XMLNS.Output_top.Outfield4.Target.*[]= InputRoot.XMLNS.Field_top.field1[];These examples show that there are several ways in which you can code ESQL tocopy repeating fields from source to target. Select the most appropriate method toachieve the results that you require.The principals shown here apply equally to all areas of the message tree to whichyou can write data, not just the output message tree.A note about copying fields:When you copy an input message element to an output element, the value and typeof the output element is set to that of the input element. Therefore, if, for example,you have an input XML document with an attribute, and you want to set a Fieldelement (rather than an attribute) in your output message to the value of the inputattribute, you must include a TYPE clause cast to change the element-type fromattribute to Field.For example, given the following input:<Field01 Attrib01='Attrib01_Value'>Field01_Value</Field01>44ESQL
To create an output, such as in the following example:<MyField_A MyAttrib_A='Attrib01_Value' MyAttrib_B='Field01_Value' ><MyField_B>Field01_Value</MyField_BC><MyField_C>Attrib01_Value</MyField_C></MyField_A'>You would use the following ESQL:-- Create output attribute from input attributeSET OutputRoot.XMLNSC.MyField_A.MyAttrib_A = InputRoot.XMLNSC.Field01.Attrib01;-- Create output field from input fieldSET OutputRoot.XMLNSC.MyField_A.MyField_B = InputRoot.XMLNSC.Field01;-- Create output attribute from input field value, noting we have to-- "cast" back to an attributeelementSET OutputRoot.XMLNSC.MyField_A.(XMLNSC.Attribute)MyAttrib_B =InputRoot.XMLNSC.Field01;-- Create output field from input attribute value, noting we have to-- "cast" back to a field elementSET OutputRoot.XMLNSC.MyField_A.(XMLNSC.Field)MyField_C =InputRoot.XMLNSC.Field01.Attrib01;Working with elements of type listThe XML Schema specification allows an element, or attribute, to contain a list ofvalues that are based on a simple type, with the individual values separated bywhite space.In the message tree, an xsd:list element is represented as a name node, with ananonymous child node for each list item. Repeating lists can be handled withoutany loss of information.Consider the following XML input message:<message1><listE1>one two three</listE1></message1>This XML element produces the following message tree:MRMlistEl(Name)"one"(Value)"two"(Value)"three" (Value)Individual list items can be accessed as ElementName.*[n].For example, use the following ESQL to access the third item of listE1:SET X = FIELDVALUE (InputBody.message1.listE1.*[3]);An attribute can also be of type xsd:list.Consider the following XML input message:<message1><Element listAttr="one two three"/></message1>This XML element produces the following message tree:Developing ESQL45
MRMElement (Name)listAttr (Name)"one" (Value)"two" (Value)"three" (Value)As before, individual list items can be accessed as AttrName.*[n].For example, use the following ESQL to access the third item of listAttr:SET X = FIELDVALUE (InputBody.message1.Element.listAttr.*[3]);A list element can occur more than once.Consider the following XML message:<message1><listE1>one two three/listE1><listE1>four five six/listE1></message1>The message tree for this XML message is:MRMlistE1 (Name)"one" (Value)"two" (Value)"three" (Value)listE1 (Name)"four" (Value)"five" (Value)"six" (Value)Code the following ESQL to access the first item in the second occurrence of thelist:SET X = FIELDVALUE (InputBody.message1.listE1[2].*[1]);Mapping between a list and a repeating element:Consider the form of the following XML input message:<MRM><inner>abcde fghij 12345</inner></MRM>where the element inner is of type xsd:list, and therefore has three associatedstring values, rather than a single value.To copy the three values into an output message, where each value is associatedwith an instance of repeating elements as shown here:<MRM><str1>abcde</str1><str1>fghij</str1><str1>12345</str1></MRM>you might expect that the following ESQL syntax works:DECLARE D INTEGER;SET D = CARDINALITY(InputBody.str1.*[]);DECLARE M INTEGER 1;46ESQL
WHILE M <= D DOSET OutputRoot.MRM.str1[M] = InputBody.inner.*[M];SET M = M + 1;END WHILE;However, the statement:SET OutputRoot.MRM.str1[M] = InputBody.inner.*[M];requests a tree copy from source to target. Because the target element does not yetexist, the statement creates it, and its value and type are set from the source.Therefore, to create the output message with the required format, given an inputelement which is of type xsd:list, use the “FIELDVALUE function” on page 323to explicitly retrieve only the value of the source element:SET OutputRoot.MRM.str1[M] = FIELDVALUE(InputBody.inner.*[M]);Manipulating repeating fields in a message treeThis topic describes the use of the SELECT function, and other column functions,to manipulate repeating fields in a message tree.Suppose that you want to perform a special action on invoices that have a totalorder value greater than a certain amount. To calculate the total order value of anInvoice field, you must multiply the Price fields by the Quantity fields in all theItems in the message, and total the result. You can do this using a SELECTexpression as follows:The example assumes that you need to use CAST expressions to cast the stringvalues of the fields Price and Quantity into the correct data types. The cast of thePrice field into a decimal produces a decimal value with the natural scale andprecision, that is, whatever scale and precision is necessary to represent thenumber. These CASTs would not be necessary if the data were already in anappropriate data type.The SELECT expression works in a similar way to the quantified predicate, and inmuch the same way that a SELECT works in standard database SQL. The FROMclause specifies what is being iterated, in this case, all Item fields in Invoice, andestablishes that the current instance of Item can be referred to using I. This form ofSELECT involves a column function, in this case the SUM function, so the SELECTis evaluated by adding together the results of evaluating the expression inside theSUM function for each Item field in the Invoice. As with standard SQL, NULLvalues are ignored by column functions, with the exception of the COUNT columnfunction explained later in this section, and a NULL value is returned by thecolumn function only if there are no non-NULL values to combine.The other column functions that are provided are MAX, MIN, and COUNT. TheCOUNT function has two forms that work in different ways with regard toNULLs. In the first form you use it much like the SUM function above, forexample:(SELECT SUM( CAST(I.Price AS DECIMAL) * CAST(I.Quantity AS INTEGER) )FROM Body.Invoice.Purchases."Item"[] AS I)Developing ESQL47
This expression returns the number of Item fields for which the Quantity field isnon-NULL. That is, the COUNT function counts non-NULL values, in the sameway that the SUM function adds non-NULL values. The alternative way of usingthe COUNT function is as follows:Using COUNT(*) counts the total number of Item fields, regardless of whether anyof the fields is NULL. The above example is in fact equivalent to using theCARDINALITY function, as in the following:In all the examples of SELECT given here, just as in standard SQL, you could use aWHERE clause to provide filtering on the fields.Manipulating other parts of the message treeYou can access message tree headers, the properties tree, the local environmenttree, the environment tree and the exception list tree.The following topics describe how you can access parts of the message tree otherthan the message body data. These parts of the logical tree are independent of thedomain in which the message exists, and all these topics apply to messages in theBLOB domain in addition to all other supported domains.v “Accessing headers”v “Accessing the Properties tree” on page 52v “Accessing the local environment tree” on page 53v “Accessing the environment tree” on page 58v “Accessing the ExceptionList tree using ESQL” on page 58Accessing headersIf the input message received by an input node includes message headers that arerecognized by the input node, the node invokes the correct parser for each header.You can access these headers using ESQL.Parsers are supplied for most WebSphere MQ headers. The following topicsprovide some guidance for accessing the information in the MQMD, MQRFH2, andMQPCF headers, which you can follow as general guidance for accessing otherheaders also present in your messages.Every header has its own correlation name, for example, MQMD, and you mustuse this name in all ESQL statements that refer to or set the content of this tree:v “Accessing the MQMD header” on page 49v “Accessing the MQRFH2 header” on page 49v “Accessing the MQCFH header” on page 50For further details of the contents of these and other WebSphere MQ headers forwhich WebSphere Message Broker provides a parser, see Element definitions formessage parsers.SELECT COUNT(I.Quantity)FROM Body.Invoice.Purchases."Item"[] AS ISELECT COUNT(*)FROM Body.Invoice.Purchases."Item"[] AS ICARDINALITY(Body.Invoice.Purchases."Item"[]48ESQL
Accessing transport headers:You can manipulate WebSphere MQ, HTTP, and JMS transport headers and theirproperties without writing Compute nodes:v Use the MQHeader node to add, modify, or delete MQ Message Descriptor(MQMD) and MQ Dead Letter Header (MQDLH) headers.v Use the HTTPHeader node to add, modify, or delete HTTP headers such asHTTPRequest and HTTPReply.v Use the JMSHeader node to modify contents of the JMS Header_Values andApplication properties so that you can control the node's output withoutprogramming.Accessing the MQMD header:Code ESQL statements to access the fields of the MQMD header.WebSphere MQ, WebSphere MQ Everyplace®, and SCADA messages include anMQMD header.You can refer to the fields within the MQMD, and you can update them in aCompute node.For example, you might want to copy the message identifier MSGID in the MQMDto another field in your output message. To do that, code:If you send a message to an EBCDIC system from a distributed system, you mightneed to convert the message to a compatible CodedCharSetId and Encoding. To dothis conversion, code the following ESQL in the Compute node:The MQMD properties of CodedCharSetId and Encoding define the code page andencoding of the section of the message that follows (typically this is either theMQRFH2 header or the message body itself).Differences exist in the way the Properties folder and the MQMD folder are treatedwith respect to which folder takes precedence for the same fields. For moreinformation, see Properties versus MQMD folder behavior for various transports.Accessing the MQRFH2 header:Code ESQL statements to access the fields of the MQRFH2 header.When you construct an MQRFH2 header in a Compute node, it includes two typesof fields:v Fields in the MQRFH2 header structure; for example, Format andNameValueCCSID.v Fields in the MQRFH2 NameValue buffer; for example, mcd and psc.To differentiate between these two field types, insert a value in front of thereferenced field in the MQRFH2 field to identify its type; a value for theSET OutputRoot.MRM.Identifier = InputRoot.MQMD.MsgId;SET OutputRoot.MQMD.CodedCharSetId = 500;SET OutputRoot.MQMD.Encoding = 785;Developing ESQL49
NameValue buffer is not required because this is the default. The value that youspecify for the header structure is (MQRFH2.Field).For example:v To create or change an MQRFH2 Format field, specify the following ESQL:v To create or change the psc folder with a topic:v To add an MQRFH2 header to an outgoing message that is to be used to make asubscription request:Variable J is initialized to the value of the cardinality of the existing headers inthe message. Using a variable is more efficient than calculating the cardinality oneach iteration of the loop, which happens if you code the following WHILEstatement:The MQRFH2 header can be parsed using either the MQRFH2 parser or theMQRFH2C compact parser. To consume less memory, use the MQRFH2C compactparser by selecting the Use MQRFH2C compact parser for MQRFH2 Header check boxon the input node of the message flow. This results in paths that containMQRFH2C instead of MQRFH2; for example: SET OutputRoot.MQRFH2C.psc.Topic= 'department';Target MQRFH2 fields are created only if the headers are copied, and theMQRFH2C parser option is not selected on the MQInput node. In all othercircumstances, an MQRFH2C field is created on output.Accessing the MQCFH header:Code ESQL statements to access the fields of the MQCFH header (root nameMQPCF).Messages that are of PCF format (MQPCF, MQADMIN, and MQEVENT) includethe MQCFH header. You can process the contents of the MQCFH header, accessingparameters, parameter lists, strings, and groups.SET OutputRoot.MQRFH2.(MQRFH2.Field)Format = 'MQSTR';SET OutputRoot.MQRFH2.psc.Topic = 'department';DECLARE I INTEGER 1;DECLARE J INTEGER CARDINALITY(InputRoot.*[]);WHILE I < J DOSET OutputRoot.*[I] = InputRoot.*[I];SET I=I+1;END WHILE;SET OutputRoot.MQRFH2.(MQRFH2.Field)Version = 2;SET OutputRoot.MQRFH2.(MQRFH2.Field)Format = 'MQSTR';SET OutputRoot.MQRFH2.(MQRFH2.Field)NameValueCCSID = 1208;SET OutputRoot.MQRFH2.psc.Command = 'RegSub';SET OutputRoot.MQRFH2.psc.Topic = "InputRoot"."MRM"."topel";SET OutputRoot.MQRFH2.psc.QMgrName = 'DebugQM';SET OutputRoot.MQRFH2.psc.QName = 'PUBOUT';SET OutputRoot.MQRFH2.psc.RegOpt = 'PersAsPub';WHILE I < CARDINALITY(InputRoot.*[]) DO50ESQL
The ParameterCount field is hidden from view to keep the value synchronized withthe true number of parameters. As a result, you cannot directly view, access, oredit the ParameterCount field and this applies when you are using:v ESQLv The Mapping Nodev Trace, or debugging code.You can implement your own ParameterCount field with a specific value, but thisvalue will be overwritten by the actual number of parameters on the flow exit.v To access or to construct parameters in the header, use the following syntax:SET OutputRoot.MQPCF.Parameter[nn] =Integer parameter IDIf you access a 64-bit parameter, use the following syntax to differentiate from32-bit parameters:SET OutputRoot.MQPCF.Parameter64[nn] =Integer parameter IDFor example:SET OutputRoot.MQPCF.Parameter[1] =MQCACF_AUTH_PROFILE_NAME;v For parameter lists, use the following syntax:SET OutputRoot.MQPCF.ParameterList64[nn] =Integer parameter IDSET OutputRoot.MQPCF.ParameterList64[nn].*[xx] =Integer parameter valuesFor example:SET OutputRoot.MQPCF.ParameterList[1] =MQIACF_AUTH_ADD_AUTHS;SET OutputRoot.MQPCF.ParameterList[1].*[1] =MQAUTH_SET;SET OutputRoot.MQPCF.ParameterList[1].*[2] =MQAUTH_SET_ALL_CONTEXT;v A byte string is a byte array data type, and is supported with this syntax:SET OutputRoot.MQPCF.Parameter[nn] =Integer parameter IDSET OutputRoot.MQPCF.Parameter[nn].* =Integer, String or ByteArray Parameter valuev A group is implemented as a folder containing more PCF, and requires thefollowing syntax:SET OutputRoot.MQPCF.Group[xx] =Group Parameter IDFor example:SET OutputRoot.MQPCF.Group[1] =MQGACF_Q_ACCOUNTING_DATA;SET OutputRoot.MQPCF.Group[1].Parameter[1] =MQCA_CREATION_DATE;SET OutputRoot.MQPCF.Group[1].Parameter[1].* ='2007-02-05';You can also use nested groups; for example;Developing ESQL51
SET OutputRoot.MQPCF.Group[1].Group[1] =MQGACF_Q_ACCOUNTING_DATA;SET OutputRoot.MQPCF.Group[1].Group[1].Parameter[1] =MQCA_CREATION_DATE;SET OutputRoot.MQPCF.Group[1].Group[1].Parameter[1].* ='2007-02-05';v A filter is almost identical to a parameter, but it also includes an operator.Therefore the syntax is a tree with named values:SET OutputRoot.MQPCF.Filter[xx] =Integer parameter IDSET OutputRoot.MQPCF.Filter[xx].Operator =Integer Filter nameSET OutputRoot.MQPCF.Filter[xx].Value =Byte, Integer or String Filter Valuev The following is sample code that can be used as an example to create anMQPCF message in a Compute node:CREATE NEXTSIBLING OF OutputRoot.Properties DOMAIN 'MQMD';CREATE NEXTSIBLING OF OutputRoot.MQMD DOMAIN 'MQADMIN'NAME 'MQPCF';CREATE FIELD OutputRoot.MQPCF;SET OutputRoot.MQMD.MsgType = MQMT_REQUEST;SET OutputRoot.MQMD.ReplyToQ = 'REPLYQ';DECLARE refRequest REFERENCE TO OutputRoot.MQPCF;SET refRequest.Type = 16; --MQCFT_COMMAND_XR z/OSSET refRequest.StrucLength = MQCFH_STRUC_LENGTH;SET refRequest.Version = 3; -- required for z/OSSET refRequest.Command = MQCMD_INQUIRE_Q;SET refRequest.MsgSeqNumber = 1;SET refRequest.Control = MQCFC_LAST;/* First parameter: Queue Name. */SET refRequest.Parameter[1] = MQCA_Q_NAME;SET refRequest.Parameter[1].* = 'QUEUENAME.*';SET refRequest.ParameterList[1] = MQIACF_Q_ATTRS;SET refRequest.ParameterList[1].*= MQIACF_ALL;Accessing the Properties treeThe Properties tree has its own correlation name, Properties, and you must use thisin all ESQL statements that refer to or set the content of this tree.The fields in the Properties tree contain values that define the characteristics of themessage. For example, the Properties tree contains message template informationfor model-driven parsers, fields for the encoding and CCSID in which messagedata is encoded, and fields that hold the security identity of the message. For a fulllist of fields in this tree, see Data types for elements in the Properties subtree.You can interrogate and update these fields using the appropriate ESQLstatements. If you create a new output message in the Compute node, you mustset values for the message properties.Setting output message properties:If you use the Compute node to generate a new output message, you must set itsproperties in the Properties tree. The output message properties do not have to bethe same as the input message properties.For example, to set the output message properties for an output MRM message, setthe following properties:52ESQL
PropertyValueMessageSetMessage set identifierMessageTypeMessage name¹MessageFormatPhysical format name²Notes:1. For details of the syntax of Message type, see Specifying namespaces inthe Message Type property.2. The name that you specify for the physical format must match thename that you have defined for it. The default physical format namesare Binary1, XML1, and Text1.This ESQL procedure sets message properties to values passed in by the callingstatement. You might find that you have to perform this task frequently, and youcan use a procedure such as this in many different nodes and message flows. Ifyou prefer, you can code ESQL that sets specific values.To set the output message domain, you can code ESQL statements that refer to therequired domain in the second qualifier of the SET statement, the parser field. Forexample, the ESQL statement sets the domain to MRM:This ESQL statement sets the domain to XMLNS:Do not specify more than one domain in the ESQL for any single message.However, if you use PROPAGATE statements to generate several output messages,you can set a different domain for each message.For information about the full list of elements in the Properties tree, see Data typesfor elements in the Properties subtree.Differences exist in the way the Properties folder and the MQMD folder are treatedwith respect to which folder takes precedence for the same fields. For moreinformation, see Properties versus MQMD folder behavior for various transports.Accessing the local environment treeThe local environment tree has its own correlation name, LocalEnvironment, andyou must use this name in all ESQL statements that refer to or set the content ofthis tree.CREATE PROCEDURE setMessageProperties(IN OutputRoot REFERENCE, IN setName char,IN typeName char, IN formatName char) BEGIN/***************************************************************************** A procedure that sets the message properties****************************************************************************/set OutputRoot.Properties.MessageSet= setName;set OutputRoot.Properties.MessageType= typeName;set OutputRoot.Properties.MessageFormat = formatName;END;SET OutputRoot.MRM.Field1 = 'field1 data';SET OutputRoot.XMLNS.Field1 = 'field1 data';Developing ESQL53
The local environment tree is used by the broker, and you can refer to and modifythis information. You can also extend the tree to contain information that youcreate yourself. You can create subtrees of this tree that you can use as ascratchpad or working area.The message flow sets up information in two subtrees, Destination andWrittenDestination, below the LocalEnvironment root. You can refer to the contentof both of these subtrees, and you can write to the Destination tree to influence theway in which the message flow processes your message. However, if you write tothe Destination tree, follow the defined structure to ensure that the tree remainsvalid.The WrittenDestination subtree contains the addresses to which the message hasbeen written. Its name is fixed and it is created by the message flow when amessage is propagated through the Out terminal of a request, output, or replynode. The subtree includes transport-specific information (for example, if theoutput message has been put to a WebSphere MQ queue, it includes the queuemanager and queue names). You can use one of the following methods to obtaininformation about the details of a message after it has been sent by the nodes:v Connect a Compute node to the Out terminal.v Configure a user exit to process an output message callback event, as describedin Exploiting user exits.The topic for each node that supports WrittenDestination information containsdetails about the data that it contains.If you want the local environment tree to be included in the output message that ispropagated by the Compute node, you must set the Compute node propertyCompute mode to a value that includes the local environment (for example, All). Ifyou do not, the local environment tree is not copied to the output message.The information that you insert into DestinationData or Defaults depends on thecharacteristic of the corresponding node property:v If a node property is represented by a check box (for example, New MessageID), set the Defaults or DestinationData element to Yes (equivalent to selectingthe check box) or No (equivalent to clearing the check box).v If a node property is represented by a drop-down list (for example, TransactionMode), set the Defaults or DestinationData element to the appropriate characterstring (for example Automatic).v If a node property is represented by a text entry field (for example, QueueManager Name), set the Defaults or DestinationData element to the characterstring that you would enter in this field.If necessary, configure the sending node to indicate where the destinationinformation is. For example, for the output node MQOutput, set Destination Mode:v If you set Destination Mode to Queue Name, the output message is sent to thequeue identified in the output node properties Queue Name and QueueManager Name. Destination is not referenced by the node.v If you set Destination Mode to Destination List, the node extracts the destinationinformation from the Destination subtree. If you use this value you can send asingle message to multiple destinations, if you configure Destination and asingle output node correctly. The node checks the node properties only if a valueis not available in Destination (as described above).54ESQL
v If you set Destination Mode to Reply To Queue, the message is sent to thereply-to queue identified in the MQMD in this message (field ReplyToQ).Destination is not referenced by the node.To find more information about ESQL procedures that perform typical updates tothe local environment, see “Populating Destination in the local environment tree”on page 56. Review the ESQL statements in these procedures to see how to modifythe local environment. You can use these procedures unchanged, or modify themfor your own requirements.To find more information about how to extend the contents of this tree for yourown purposes, see “Using scratchpad areas in the local environment.”For another example of how you can use the local environment to modify thebehavior of a message flow, refer to the XML_PassengerQuery message flow in thefollowing sample program:v Airline ReservationsThe Compute node in this message flow writes a list of destinations in theRouterList subtree of Destination that are used as labels by a later RouteToLabelnode that propagates the message to the corresponding Label node. You can viewsamples information only when you use the information center that is integratedwith the Message Broker Toolkit or the online information center.Using scratchpad areas in the local environment:The local environment tree includes a subtree called variables. This subtree isalways created, but is never populated by the message flow. Use this area for yourown purposes; for example, to pass information from one node to another. You cancreate other subtrees of the local environment tree.The advantage of creating your own data in a scratchpad in the local environmentis that this data can be propagated as part of the logical tree to subsequent nodesin the message flow. If you create a new output message in a Compute node, youcan also include all or part of the local environment tree from the input message inthe new output message.To ensure that the information in the local environment is propagated furtherdown the flow, the Compute mode property of the Compute node must be set toinclude the local environment as part of the output tree (for example, specifyLocalEnvironment and Message). For further details about the Compute modeproperty, see Setting the mode.However, any data updates or additions that you make in one node are notretained if the message moves backwards through the message flow (for example,if an exception is thrown). If you create your own data, and want that data to bepreserved throughout the message flow, you must use the environment tree.You can set values in the variables subtree in a Compute node and those valuescan be used later by another node (Compute, Database, or Filter) for some purposethat you determine when you configure the message flow.The local environment is not in scope in a Compute node, therefore you must useInputLocalEnvironment and OutputLocalEnvironment instead. For example, youmight use the scratchpad in the local environment to propagate the destination ofan output message to subsequent nodes in a message flow. Your first ComputeDeveloping ESQL55
node determines that the output messages from this message flow must go toWebSphere MQ queues. Include the following ESQL to insert this information intothe local environment by setting the value of OutputLocation in theOutputLocalEnvironment:SET OutputLocalEnvironment.Variables.OutputLocation = 'MQ';Your second Compute node can access this information from its input message. Inthe ESQL in this node, use the correlation name InputLocalEnvironment to identifythe local environment tree in the input message that contains this data. Thefollowing ESQL sets queueManagerName and queueName based on the content ofOutputLocation in the local environment, by using InputLocalEnvironment:IF InputLocalEnvironment.Variables.OutputLocation = 'MQ' THENSET OutputLocalEnvironment.Destination.MQ.DestinationData.queueManagerName = 'myQManagerName';SET OutputLocalEnvironment.Destination.MQ.DestinationData.queueName = 'myQueueName';END IF;In the example, queueManagerName and queueName are set for the Destinationsubtree in the output message. You must set the Compute mode of the secondCompute node to include the local environment tree in the output message.Configure the MQOutput node to use the destination list that you have created inthe local environment tree by setting the Destination Mode property to DestinationList.For information about the full list of elements in the DestinationData subtree, seeData types for elements in the MQ DestinationData subtree.Populating Destination in the local environment tree:Use the Destination subtree to set up the target destinations that are used byoutput nodes, the HTTPRequest node, the SOAPRequest node, theSOAPAsyncRequest node, and the RouteToLabel node. The following examplesshow how you can create and use an ESQL procedure to perform the task ofsetting up values for each of these uses.Copy and use these procedures as shown, or you can modify or extend them toperform similar tasks.If you are creating this ESQL code for a Compute node, you must configure thenode by setting the Compute Mode property so that it has access to the localenvironment tree in the output message. You must select one of the three valuesLocalEnvironment, LocalEnvironment And Message, or All.Adding a queue name for the MQOutput node with the Destination Modeproperty set to Destination ListCREATE PROCEDURE addToMQDestinationList(IN LocalEnvironment REFERENCE, IN newQueue char) BEGIN/******************************************************************************** A procedure that adds a queue name to the MQ destination list in the local environment.* This list is used by an MQOutput node that has its mode set to Destination list.** IN LocalEnvironment: the LocalEnvironment to be modified.* IN queue: the queue to be added to the list********************************************************************************/DECLARE I INTEGER CARDINALITY(LocalEnvironment.Destination.MQ.DestinationData[]);IF I = 0 THENSET OutputLocalEnvironment.Destination.MQ.DestinationData[1].queueName = newQueue;56ESQL
ELSESET OutputLocalEnvironment.Destination.MQ.DestinationData[I+1].queueName = newQueue;END IF;END;For full details of these elements, see Data types for elements in the MQDestinationData subtree.Changing the default URL for a SOAPRequest node or a SOAPAsyncRequestnode requestCREATE PROCEDURE overrideDefaultSOAPRequestURL(IN LocalEnvironment REFERENCE, IN newUrl char) BEGIN/******************************************************************************** A procedure that changes the URL to which the SOAPRequest node or* SOAPAsyncRequest node sends the request.** IN LocalEnvironment: the LocalEnvironment to be modified.* IN queue:the URL to which to send the request.********************************************************************************/SET OutputLocalEnvironment.Destination.SOAP.Request.Transport.HTTP.WebServiceURL = newUrl;END;Changing the default URL for an HTTPRequest node requestCREATE PROCEDURE overrideDefaultHTTPRequestURL(IN LocalEnvironment REFERENCE, IN newUrl char) BEGIN/******************************************************************************** A procedure that changes the URL to which the HTTPRequest node sends the request.** IN LocalEnvironment: the LocalEnvironment to be modified.* IN queue: the URL to which to send the request.********************************************************************************/SET OutputLocalEnvironment.Destination.HTTP.RequestURL = newUrl;END;Adding a label for the RouteToLabel nodeCREATE PROCEDURE addToRouteToLabelList(IN LocalEnvironment REFERENCE, IN newLabel char) BEGIN/******************************************************************************** A procedure that adds a label name to the RouteToLabel list in the local environment.* This list is used by a RoteToLabel node.** IN LocalEnvironment: the LocalEnvironment to be modified.* IN label:the label to be added to the list********************************************************************************/IF LocalEnvironment.Destination.RouterList.DestinationData is null THENSET OutputLocalEnvironment.Destination.RouterList.DestinationData."label" = newLabel;ELSECREATE LASTCHILD OF LocalEnvironment.Destination.RouterList.DestinationDataNAME 'label' VALUE newLabel;END IF;END;Setting up JMS destination listsYou can configure a JMSOutput node to send to multiple JMS Queues, orto publish to multiple JMS Topics by using a destination list that is createdin the local environment tree by a transformation node. The followingexample shows how to set up JMS destination lists in the localenvironment tree:CREATE PROCEDURE CreateJMSDestinationList() BEGINSET OutputLocalEnvironment.Destination.JMSDestinationList.DestinationData[1]= 'jndi://TestDestQueue1';SET OutputLocalEnvironment.Destination.JMSDestinationList.DestinationData[2]= 'jndi://TestDestQueue2';SET OutputLocalEnvironment.Destination.JMSDestinationList.DestinationData[3]= 'jndi://TestDestQueue3';END;Developing ESQL57
Accessing the environment treeThe environment tree has its own correlation name, Environment, and you mustuse this name in all ESQL statements that refer to, or set, the content of this tree.The environment tree is always created when the logical tree is created for aninput message. However, the message flow neither populates it, nor uses itscontents. You can use this tree for your own purposes, for example, to passinformation from one node to another. You can use the whole tree as a scratchpador working area.The advantage of creating your own data in environment is that this data ispropagated as part of the logical tree to subsequent nodes in the message flow. Ifyou create a new output message in a Compute node, the environment tree is alsocopied from the input message to the new output message. (In contrast to the localenvironment tree, which is only included in the output message if you explicitlyrequest that it is).Only one environment tree is present for the duration of the message flow. Anydata updates, or additions, that you make in one node are retained, and all of thenodes in the message flow have access to the latest copy of this tree. Even if themessage flows back through the message flow (for example, if an exception isthrown, or if the message is processed through the second terminal of theFlowOrder node), the latest state is retained. (In contrast to the local environmenttree, which reverts to its previous state if the message flows back through themessage flow.)You can use this tree for any purpose you choose. For example, you can use thefollowing ESQL statements to create fields in the tree:This information is now available to all nodes to which a message is propagated,regardless of their relative position in the message flow.For another example of how you can use environment to store information used byother nodes in the message flow, look at the Reservation message flow in thefollowing sample:v Airline ReservationsThe Compute node in this message flow writes information to the subtreeEnvironment.Variables that it has extracted from a database according to the valueof a field in the input message.You can view samples information only when you use the information center thatis integrated with the Message Broker Toolkit or the online information center.Accessing the ExceptionList tree using ESQLThe ExceptionList tree has its own correlation name, ExceptionList, and you mustuse this in all ESQL statements that refer to or set the content of this tree.This tree is created with the logical tree when an input message is parsed. It isinitially empty, and is only populated if an exception occurs during message flowSET Environment.Variables =ROW('granary' AS bread, 'reisling' AS wine, 'stilton' AS cheese);SET Environment.Variables.Colors[] =LIST{'yellow', 'green', 'blue', 'red', 'black'};SET Environment.Variables.Country[] = LIST{ROW('UK' AS name, 'pound' AS currency),ROW('USA' AS name, 'dollar' AS currency)};58ESQL
processing. It is possible that more than one exception can occur; if more than oneexception occurs, the ExceptionList tree contains a subtree for each exception.You can access the ExceptionList tree in Compute, Database, and Filter nodes, andyou can update it in a Compute node. You must use the appropriate correlationname; ExceptionList for a Database or Filter node, and InputExceptionList for aCompute node.You might want to access this tree in a node in an error handling procedure. Forexample, you might want to route the message to a different path based on thetype of exception, for example one that you have explicitly generated using anESQL THROW statement, or one that the broker has generated.The following ESQL shows how you can access the ExceptionList and process eachchild that it contains:The following example shows an extract of ESQL that has been coded for aCompute node to loop through the exception list to the last (nested) exceptiondescription and extract the error number. This error relates to the original cause ofthe problem and normally provides the most precise information. Subsequentaction taken by the message flow can be decided by the error number retrieved inthis way.For more information about the use of ExceptionList, look at the subflow in thefollowing sample which includes ESQL that interrogates the ExceptionListstructure and takes specific action according to its content:-- Declare a reference for the ExceptionList-- (in a Compute node use InputExceptionList)DECLARE start REFERENCE TO ExceptionList.*[1];-- Loop through the exception list childrenWHILE start.Number IS NOT NULL DO-- more ESQL-- Move start to the last child of the field to which it currently pointsMOVE start LASTCHILD;END WHILE;CREATE PROCEDURE getLastExceptionDetail(IN InputTree reference,OUT messageNumber integer,OUT messageText char)/***************************************************************************** A procedure that will get the details of the last exception from a message* IN InputTree:The incoming exception list* IN messageNumber:The last message numberr.* IN messageText: The last message text.*****************************************************************************/BEGIN-- Create a reference to the first child of the exception listdeclare ptrException reference to InputTree.*[1];-- keep looping while the moves to the child of exception list workWHILE lastmove(ptrException) DO-- store the current values for the error number and textIF ptrException.Number is not null THENSET messageNumber = ptrException.Number;SET messageText = ptrException.Text;END IF;-- now move to the last child which should be the next exceptionlistmove ptrException lastchild;END WHILE;END;Developing ESQL59
v Error HandlerYou can view samples information only when you use the information center thatis integrated with the Message Broker Toolkit or the online information center.For information on accessing the ExceptionList tree using Java, see Accessing theExceptionList tree using JavaTransforming from one data type to anotherCode ESQL functions and statements to transform messages and data types inmany ways.The following topics provide guidance:v “Casting data from message fields”v “Converting code page and message encoding”v “Converting EBCDIC NL to ASCII CR LF” on page 63v “Changing message format” on page 65Casting data from message fieldsYou can use the CAST function to transform the data type of one value to matchthe data type of the other. For example, you can use the CAST function when youprocess generic XML messages. All fields in an XML message have charactervalues, so if you want to perform arithmetic calculations or datetime comparisons,for example, you must convert the string value of the field into a value of theappropriate type using CAST.When you compare an element with another element, variable or constant, ensurethat the value with which you are comparing the element is consistent (forexample, character with character). If the values are not consistent, the brokergenerates a runtime error if it cannot provide an implicit casting to resolve theinconsistency. For details of what implicit casts are supported, see “Implicit casts”on page 365.In the Invoice message, the field InvoiceDate contains the date of the invoice. Ifyou want to refer to or manipulate this field, you must CAST it to the correctformat first. For example, to refer to this field in a test:This converts the string value of the InvoiceDate field into a date value, andcompares it to the current date.Another example is casting from integer to character:Converting code page and message encodingYou can use ESQL within a Compute node to convert data for code page andmessage encoding.IF CAST(Body.Invoice.InvoiceDate AS DATE) = CURRENT_DATE THENDECLARE I INTEGER 1;DECLARE C CHARACTER;-- The following statement generates an errorSET C = I;-- The following statement is validSET C = CAST(I AS CHARACTER);60ESQL
If your message flow is processing WebSphere MQ messages, you can useWebSphere MQ facilities (including get and put options and WebSphere MQ dataconversion exits) to provide these conversions. If you are not processingWebSphere MQ messages, or you choose not to use WebSphere MQ facilities, youcan use WebSphere Message Broker facilities by coding the appropriate ESQL in aCompute node in your message flow.The contents of the MQMD, the MQRFH2, and the message body of a message inthe MRM domain that has been modeled with a CWF physical format can besubject to code page and encoding conversion. The contents of a message body ofa message in the XML, XMLNS, and JMS domains, and those messages in theMRM domain that have been modeled with an XML or TDS physical format, aretreated as strings. Only code page conversion applies; no encoding conversion isrequired.For messages in the MRM domain modeled with a CWF physical format, you canset the MQMD CCSID and Encoding fields of the output message, plus the CCSIDand Encoding of any additional headers, to the required target value.For messages in the MRM domain modeled with an XML or TDS physical format,you can set the MQMD CCSID field of the output message, plus the CCSID of anyadditional headers. XML and TDS data is handled as strings and is thereforesubject to CCSID conversion only.An example WebSphere MQ message has an MQMD header, an MQRFH2 header,and a message body. To convert this message to a mainframe CodedCharSetId andEncoding, code the following ESQL in the Compute node:The following example illustrates what you must do to modify a CWF message sothat it can be passed from WebSphere Message Broker to IMS™on z/OS®.1. You have defined the input message in XML and are using an MQRFH2header. Remove the header before passing the message to IMS.2. The message passed to IMS must have MQIIH header, and must be in thez/OS code page. This message is modeled in the MRM and has the nameIMS1. Define the PIC X fields in this message as logical type string forconversions between EBCDIC and ASCII to take place. If the fields are binarylogical type, no data conversion occurs; binary data is ignored when a CWFmessage is parsed by the MRM parser.3. The message received from IMS is also defined in the MRM and has the nameIMS2. Define the PIC X fields in this message as logical type string forconversions between EBCDIC and ASCII to take place. If the fields are binarylogical type, no data conversion occurs; binary data is ignored when a CWFmessage is parsed by the MRM parser.4. Convert the reply message to the Windows® code page. The MQIIH header isretained on this message.5. You have created a message flow that contains the following nodes: :a. The outbound flow, MQInput1 --> Compute1 --> MQOutput1.b. The inbound flow, MQInput2 --> Compute2 --> MQOutput2.6. Code ESQL in Compute1 (outbound) node as follows, specifying the relevantMessageSet ID. This code shows the use of the default CWF physical layerSET OutputRoot.MQMD.CodedCharSetId = 500;SET OutputRoot.MQMD.Encoding = 785;SET OutputRoot.MQRFH2.CodedCharSetId = 500;SET OutputRoot.MQRFH2.Encoding = 785;Developing ESQL61
name. You must use the name that matches your model definitions. If youspecify an incorrect value, the broker fails with message BIP5431.The use of a variable, J, that is initialized to the value of the cardinality of theexisting headers in the message, is more efficient than calculating thecardinality on each iteration of the loop, which happens if you code thefollowing WHILE statement:7. Create ESQL in Compute2 (inbound) node as follows, specifying the relevantMessageSet ID. This code shows the use of the default CWF physical layername. You must use the name that matches your model definition. If youspecify an incorrect value, the broker fails with message BIP5431.-- Loop to copy message headersDECLARE I INTEGER 1;DECLARE J INTEGER CARDINALITY(InputRoot.*[]);WHILE I < J - 1 DOSET OutputRoot.*[I] = InputRoot.*[I];SET I=I+1;END WHILE;SET OutputRoot.MQMD.CodedCharSetId = 500;SET OutputRoot.MQMD.Encoding = 785;SET OutputRoot.MQMD.Format = 'MQIMS';SET OutputRoot.MQIIH.Version = 1;SET OutputRoot.MQIIH.StrucLength = 84;SET OutputRoot.MQIIH.Encoding = 785;SET OutputRoot.MQIIH.CodedCharSetId = 500;SET OutputRoot.MQIIH.Format = 'MQIMSVS ';SET OutputRoot.MQIIH.Flags = 0;SET OutputRoot.MQIIH.LTermOverride = '';SET OutputRoot.MQIIH.MFSMapName = '';SET OutputRoot.MQIIH.ReplyToFormat = 'MQIMSVS ';SET OutputRoot.MQIIH.Authenticator = '';SET OutputRoot.MQIIH.TranInstanceId = X'00000000000000000000000000000000';SET OutputRoot.MQIIH.TranState = ' ';SET OutputRoot.MQIIH.CommitMode = '0';SET OutputRoot.MQIIH.SecurityScope = 'C';SET OutputRoot.MQIIH.Reserved = ' ';SET OutputRoot.MRM.e_elen08 = 30;SET OutputRoot.MRM.e_elen09 = 0;SET OutputRoot.MRM.e_string08 = InputBody.e_string01;SET OutputRoot.MRM.e_binary02 = X'31323334353637383940';SET OutputRoot.Properties.MessageSet = 'DHCJOEG072001';SET OutputRoot.Properties.MessageType = 'IMS1';SET OutputRoot.Properties.MessageFormat = 'Binary1';WHILE I < CARDINALITY(InputRoot.*[]) DO62ESQL
You do not have to set any specific values for the MQInput1 node properties,because the message and message set are identified in the MQRFH2 header, andno conversion is required.You must set values for message domain, set, type, and format in the MQInputnode for the inbound message flow (MQInput2). You do not need to set conversionparameters.One specific situation in which you might need to convert data in one code pageto another is when messages contain newline characters and are passed betweenEBCDIC and ASCII systems. The required conversion for this situation is describedin “Converting EBCDIC NL to ASCII CR LF.”Converting EBCDIC NL to ASCII CR LF:You might want to change newline (NL) characters in a text message to carriagereturn (CR) and line feed (LF) character pairs. This example shows one way inwhich you can convert these characters.This conversion might be useful if messages from an EBCDIC platform (forexample, using CCSID 1047) are sent to an ASCII platform (for example, usingCCSID 437). Problems can arise because the EBCDIC NL character hex '15' isconverted to the undefined ASCII character hex '7F'. The ASCII code page has nocorresponding code point for the NL character.In this example, a message flow is created that interprets the input message as amessage in the BLOB domain. This message is passed into aResetContentDescriptor node to reset the data to a message in the MRM domain.The message is called msg_nl (a set of repeating string elements delimited byEBCDIC NL characters). A Compute node is then used to create an output basedon another message in the MRM domain called msg_crlf (a set of repeating stringelements delimited by CR LF pairs). The message domain is then changed back toBLOB in another ResetContentDescriptor node. This message flow is shown in thefollowing diagram.-- Loop to copy message headersDECLARE I INTEGER 1;DECLARE J INTEGER CARDINALITY(InputRoot.*[]);WHILE I < J DOSET OutputRoot.*[I] = InputRoot.*[I];SET I=I+1;END WHILE;SET OutputRoot.MQMD.CodedCharSetId = 437;SET OutputRoot.MQMD.Encoding = 546;SET OutputRoot.MQMD.Format = 'MQIMS';SET OutputRoot.MQIIH.CodedCharSetId = 437;SET OutputRoot.MQIIH.Encoding = 546;SET OutputRoot.MQIIH.Format = '';SET OutputRoot.MRM = InputBody;SET OutputRoot.Properties.MessageSet = 'DHCJOEG072001';SET OutputRoot.Properties.MessageType = 'IMS2';SET OutputRoot.Properties.MessageFormat = 'Binary1';Developing ESQL63
MQInputMQOutputComputeResetContentDescriptorResetContentDescriptor1The following instructions show how to create the messages and configure themessage flow.1. Create the message models for the messages in the MRM domain:a. Create a message set project called myProj.b. Create a message set called myMessageSet with a TDS physical format (thedefault name is Text1).c. Create an element string1 of type xsd:string.d. Create a complex type called t_msg_nl and specify the following complextype properties:v Composition = Ordered Setv Content Validation = Closedv Data Element Separation = All Elements Delimitedv Delimiter = <U+0085> (hex '0085' is the UTF-16 representation of an NLcharacter)v Repeat = Yesv Min Occurs = 1v Max Occurs = 50 (the text of the message is assumed to consist of nomore than 50 lines)e. Add Element string1, and set the following property:v Repeating Element Delimiter = <U+0085>f. Create a Message msg_nl, and set its associated complex type to t_msg_nlg. Create a complex type called t_msg_crlf, and specify the following complextype properties:v Composition = Ordered Setv Content Validation = Closedv Data Element Separation = All Elements Delimitedv Delimiter = <CR><LF> (<CR> and <LF> are the mnemonics for the CRand LF characters)v Repeat = Yesv Min Occurs = 1v Max Occurs = 50h. Add Element string1, and set the following property:v Repeating Element Delimiter = <CR><LF>i. Create a Message msg_crlf, and set complex type to t_msg_crlf.2. Configure the message flow shown in the previous figure:a. Start with the MQInput node:v Set Message Domain = BLOBv Set Queue Name = <Your input message queue name>b. Add the ResetContentDescriptor node, connected to the Out terminal of theMQInput node:v Set Message Domain = MRM64ESQL
v Select Reset Message Domainv Set Message Set = <Your Message Set ID> (this field has a maximum of13 characters)v Select Reset Message Setv Set Message Type = msg_nlv Select Reset Message Typev Set Message Format = Text1v Select Reset Message Formatc. Add the Compute node, connected to the Out terminal of theResetContentDescriptor node:v Enter a name for the ESQL Module for this node, or accept the default(<message flow name>_Compute).v Right-click the Compute node, and select Open ESQL. Add the followingESQL code in the module:The use of a variable, J, initialized to the value of the cardinality of theexisting headers in the message, is more efficient than calculating thecardinality on each iteration of the loop, which happens if you code thefollowing WHILE statement:d. Add the ResetContentDescriptor1 node, connected to the Out terminal ofthe Compute node:v Set Message Domain = BLOBv Select Reset Message Domain.e. Finally, add the MQOutput node, connected to the Out terminal of theResetContentDescriptor1 node. Configure its properties to direct the outputmessage to the required queue or queues.Changing message formatUse the Compute node to copy part of an input message to an output message.The results of such a copy depend on the type of input and output parsersinvolved.Like parsers:-- Declare local working variablesDECLARE I INTEGER 1;DECLARE J INTEGER CARDINALITY(InputRoot.*[]);-- Loop to copy all message headers from input to output messageWHILE I < J DOSET OutputRoot.*[I] = InputRoot.*[I];SET I=I+1;END WHILE;-- Set new output message type which uses CRLF delimiterSET OutputRoot.Properties.MessageType = 't_msg_crlf';-- Loop to copy each instance of string1 child within message bodySET I = 1;SET J = CARDINALITY("InputBody"."string1"[]);WHILE I <= J DOSET "OutputRoot"."MRM"."string1"[I] = "InputBody"."string1"[I];SET I=I+1;END WHILE;WHILE I < CARDINALITY(InputRoot.*[]) DODeveloping ESQL65
Where both the source and target messages have the same folder structure at rootlevel, a like-parser-copy is performed. For example:This statement copies all the children in the MQMD folder of the input message tothe MQMD folder of the output message.Another example of a tree structure that supports a like-parser-copy is:To transform an input message in the MRM domain to an output message also inthe MRM domain, you can use either the Compute or the Mapping node. TheMapping node can interpret the action that is required because it knows the formatof both messages. Content Assist in the ESQL module for the Compute node canalso use the message definitions for those messages. If the messages are not in thesame namespace, you must use the Compute node.To use Content Assist with message references, you must set up a project referencefrom the project containing the ESQL to the project containing the message set. Forinformation about setting up a project reference, see Project references.If both input and output messages are not in the MRM domain, you must use theCompute node and specify the structure of the messages yourself.Unlike parsers:Where the source and target messages have different folder structures at root level,you cannot make an exact copy of the message source. Instead, theunlike-parser-copy views the source message as a set of nested folders terminated bya leaf name-value pair. For example, copying the following message from XML toMRM:produces a name element Name3, and a name-value element called Name31 withthe value Value31. The second XML pcdata (Value32) cannot be represented and isdiscarded.The unlike-parser-copy scans the source tree, and copies folders, also known asname elements, and leaf name-value pairs. Everything else, including elementsflagged as special by the source parser, is not copied.An example of a tree structure that results in an unlike-parser-copy is:If the algorithm used to make an unlike-parser-copy does not suit your treestructure, you should further qualify the source field to restrict the amount of thetree that is copied.Be careful when you copy information from input messages to output messages indifferent domains. You could code ESQL that creates a message structure orcontent that is not completely consistent with the rules of the parser that processesthe output message. This action can result in an output message not being created,or being created with unexpected content. If you believe that the output messageSET OutputRoot.MQMD = InputRoot.MQMD;SET OutputRoot.XMLNS.Data.Account = InputRoot.XMLNS.Customer.Bank.Data;<Name3><Name31>Value31</Name31>Value32</Name3>SET OutputRoot.MRM.Data.Account = InputRoot.XMLNS.Data.Account;66ESQL
generated by a particular message flow does not contain the correct content, orhave the expected form, check the ESQL that creates the output message, and lookfor potential mismatches of structure, field types, field names, and field values.When copying trees between unlike parsers, you should set the message format ofthe target parser. For example, if a message set has been defined with XMLNS andCWF formats, the following commands are required to copy an input XMLNSstream to the MRM parser and set the latter to be generated in CWF format:-- Copy message to the output, moving from XMLNS to MRM domainsSET OutputRoot.MRM = InputRoot.XMLNS.rootElement;-- Set the CWF format for output by the MRM domainSET OutputRoot.Properties.MessageType = '<MessageTypeName>';SET OutputRoot.Properties.MessageSet = '<MessageSetName>';SET OutputRoot.Properties.MessageFormat = 'CWF';Adding keywords to ESQL filesYou can add keywords to ESQL files to contain information that you want toassociate with a message flow.Use one or more of the following methods:Comment fieldsAdd the keyword as a comment in the ESQL file:-- $MQSI compiled by = John MQSI$Static stringsInclude the keyword as part of a static string in the ESQL file:SET target = '$MQSI_target = production only MQSI$'Variable stringInclude the keyword value as a variable string in the ESQL file:$MQSI_VERSION=$id$MQSI$In this example, when the message flow source is extracted from the filerepository, the repository's plug-in has been configured to substitute theidentifier $id$ with the actual version number. The identifier value that isrequired depends on the capability and configuration of the repository, andis not part of WebSphere Message Broker.Restrictions within keywordsDo not use the following characters within keywords, because they causeunpredictable behavior:^ $ . | \ < > ? + * = & [ ] ( )You can use these characters in the values that are associated with keywords; forexample:v $MQSI RCSVER=$id$ MQSI$ is acceptablev $MQSI $name=Fred MQSI$ is not acceptableInteraction with databases using ESQLUse ESQL statements and functions to read from, write to, and modify databasesfrom your message flows.Developing ESQL67
ESQL has a number of statements and functions for accessing databases:v The “CALL statement” on page 196 invokes a stored procedure.v The “DELETE FROM statement” on page 243 removes rows from a databasetable.v The “INSERT statement” on page 249 adds a row to a database table.v The “PASSTHRU function” on page 373 can be used to make complex selections.v The “PASSTHRU statement” on page 259 can be used to invoke administrativeoperations (for example, creating a table).v The “SELECT function” on page 345 retrieves data from a table.v The “UPDATE statement” on page 272 changes one or more values stored inzero or more rows.You can access user databases from Compute, Database, and Filter nodes. Thedatabase access capabilities of all these nodes is identical.You can use the data in the databases to update or create messages, or use the datain the message to update or create data in the databases.Select Throw exception on database error and Treat warnings as errors, and setTransaction to Automatic on each node that access a database, to providemaximum flexibility.For information about configuring the broker and the database to support accessfrom message flows, see Accessing databases from ESQL.v “Referencing columns in a database”v “Selecting data from database columns” on page 70v “Accessing multiple database tables” on page 74v “Changing database content” on page 75v “Checking returns to SELECT” on page 76v “Committing database updates” on page 77v “Invoking stored procedures” on page 77Referencing columns in a databaseWhile the standard SQL SELECT syntax is supported for queries to an externaldatabase, there are a number of points to be borne in mind. You must prefix thename of the table with the keyword Database to indicate that the SELECT is to betargeted at the external database, rather than at a repeating structure in themessage.The basic form of database SELECT is:If necessary, you can specify a schema name:where SCHEMA is the name of the schema in which the table TABLE1 is defined.Include the schema if the user ID under which you are running does not match theschema. For example, if your userID is USER1, the expression Database.TABLE1 isSELECT ...FROM Database.TABLE1WHERE ...SELECT ...FROM Database.SCHEMA.TABLE1WHERE ...68ESQL
equivalent to Database.USER1.TABLE1. However, if the schema associated with thetable in the database is db2admin, you must specify Database.db2admin.TABLE1.If you do not include the schema, and this does not match your current user ID,the broker generates a runtime error when a message is processed by the messageflow.If, as in the two previous examples, a data source is not specified, TABLE1 must bea table in the default database specified by the node’s data source property. Toaccess data in a database other than the default specified on the node’s datasource property, you must specify the data source explicitly. For example:Qualify references to column names with either the table name or the correlationname defined for the table by the FROM clause. So, where you could normallyexecute a query such as:you must write one of the following two forms:This is necessary in order to distinguish references to database columns from anyreferences to fields in a message that might also appear in the SELECT:You can use the AS clause to rename the columns returned. For example:The standard select all SQL option is supported in the SELECT clause. If you usethis option, you must qualify the column names with either the table name or thecorrelation name defined for the table. For example:When you use ESQL procedure and function names within a database query, thepositioning of these within the call affects how these names are processed. If it isdetermined that the procedure or function affects the results returned by the query,it is not processed as ESQL and is passed as part of the database call.This applies when attempting to use a function or procedure name with thecolumn identifiers within the SELECT statement.For example, if you use a CAST statement on a column identifier specified in theSelect clause, this is used during the database query to determine the data type ofthe data being returned for that column. An ESQL CAST is not performed to thatESQL data type, and the data returned is affected by the database interaction'sinterpretation of that data type.SELECT ...FROM Database.DataSource.SCHEMA.TABLE1WHERE ...SELECT column1, column2 FROM table1SELECT T.column1, T.column2 FROM Database.table1 AS TSELECT table1.column1, table1.column2 FROM Database.table1SELECT T.column1, T.column2 FROM Database.table1AS T WHERE T.column3 = Body.Field2SELECT T.column1 AS price, T.column2 AS itemFROM Database.table1 AS T WHERE...SELECT T.* FROM Database.Table1 AS TDeveloping ESQL69
If you use a function or procedure on a column identifier specified in the WHEREclause, this is passed directly to the database manager for processing.The examples in the subsequent topics illustrate how the results sets of externaldatabase queries are represented in WebSphere Message Broker. The results ofdatabase queries are assigned to fields in a message using a Compute node.A column function is a function that takes the values of a single column in all theselected rows of a table or message and returns a single scalar result.Selecting data from database columnsYou can configure a Compute, Filter, or Database node to select data from databasecolumns and include it in an output message.The following example assumes that you have a database table called USERTABLEwith two char(6) data type columns (or equivalent), called Column1 and Column2.The table contains two rows:Column1Column2Row 1value1value2Row 2value3value4Configure the Compute, Filter, or Database node to identify the database in whichyou have defined the table. For example, if you are using the default database(specified on the data source property of the node), right-click the node, selectOpen ESQL, and code the following ESQL statements in the module for this node:This ESQL produces the following output message:To trigger the SELECT, send a trigger message with an XML body that is of thefollowing form:SET OutputRoot = InputRoot;DELETE FIELD OutputRoot.*[<];SET OutputRoot.XML.Test.Result[] =(SELECT T.Column1, T.Column2 FROM Database.USERTABLE AS T);<Test><Result><Column1>value1</Column1><Column2>value2</Column2></Result><Result><Column1>value3</Column1><Column2>value4</Column2></Result></Test>Figure 1. Output message70ESQL
The exact structure of the XML is not important, but the enclosing tag must be<Test> to match the reference in the ESQL. If the enclosing tag is not <Test>, theESQL statements result in top-level enclosing tags being formed, which is not validXML.If you want to create an output message that includes all the columns of all therows that meet a particular condition, use the SELECT statement with a WHEREclause:The message fields are created in the same order as the columns occur in the table.If you are familiar with SQL in a database environment, you might expect to codeSELECT *. This syntax is not accepted by the broker, because you must start allreferences to columns with a correlation name to avoid ambiguities with declaredvariables. Also, if you code SELECT I.*, this syntax is accepted by the broker, butthe * is interpreted as the first child element, not all elements, as you might expectfrom other database SQL.The assignment of the result set of a database into a parser-owned message treerequires the result set to exactly match the message definition. Because the genericXML parser is self-defining, the example creates a new subtree off the Invoicefolder, and the parser can parse the new elements in the subtree. If the structure ofthe result set exactly matches the message definition, the result set can be assigneddirectly into the OutputRoot message body tree.If the structure of the result set does not exactly match the MRM messagedefinition, you must first assign the result set into a ROW data type, or anEnvironment tree that does not have a parser associated with it.The required data can then be assigned to OutputRoot to build a message tree thatconforms to the message definition.Selecting data from a table in a case-sensitive database system:If the database system is case sensitive, you must use an alternative approach. Thisapproach is also necessary if you want to change the name of the generated fieldto something different:<Test><Result><Column1></Column1><Column2></Column2></Result><Result><Column1></Column1><Column2></Column2></Result></Test>-- Declare and initialize a variable to hold the--test vaue (in this case the surname Smith)DECLARE CurrentCustomer STRING 'Smith';-- Loop through table records to extract matching informationSET OutputRoot.XML.Invoice[] =(SELECT R FROM Database.USERTABLE AS RWHERE R.Customer.LastName = CurrentCustomer);Developing ESQL71
This example produces the output message as shown in Figure 1 on page 70.Ensure that references to the database columns (in this example, T.Column1 andT.Column2) are specified in the correct case to match the database definitionsexactly. If you do not match the database definitions exactly (for example if youspecify T.COLUMN1), the broker generates a runtime error. Column1 and Column2are used in the SELECT statement to match the columns that you have defined inthe database, although you can use any values here; the values do not have tomatch.Selecting bitstream data from a database:These samples show how to retrieve XML bitstream data from a database, andinclude it in an output message. See “INSERT statement” on page 249 for examplesthat show how you can insert bitstream data into a database.In the following example, bitstream data is held in a database column with a BLOBdata type. The database table used in the example (TABLE1) is the one created inthe “INSERT statement” on page 249 examples, and the table contains thefollowing columns:v MSGDATAv MSGCCSIDv MSGENCODINGIf the bit stream from the database does not need to be interrogated ormanipulated by the message flow, the output message can be constructed in theBLOB domain without any alteration.In the following example, the message data, along with the MQMD header, is heldin a database column with a BLOB data type. To re-create the message tree,including the MQMD header, from the bit stream, you can use a CREATEstatement with a PARSE clause and DOMAIN('MQMD'). The output message can thenbe modified by the message flow:SET Environment.Variables.DBResult = THE( SELECT T.* FROM Database.TABLE1 AS T);DECLARE resultRef REFERENCE TO Environment.Variables.DBResult;IF LASTMOVE(resultRef) THENDECLARE outMsg BLOB resultRef.MSGDATA ;DECLARE outCCSID INT resultRef.MSGCCSID;DECLARE outEncoding INT resultRef.MSGENCODING;DECLARE outMsgPriority INT resultRef.MSGPRIORITY;DECLARE outMsgSeqNum INT resultRef.MSGSEQNUMBER;SET OutputRoot.Properties.CodedCharSetId = outCCSID;SET OutputRoot.Properties.Encoding = outEncoding ;CREATE LASTCHILD OF OutputRoot DOMAIN('MQMD') PARSE(outMsg, outEncoding, outCCSID);SET OutputRoot.MQMD.Version = MQMD_VERSION_2;SET OutputRoot.MQMD.Priority = outMsgPriority;SET OutputRoot.MQMD.MsgSeqNumber = outMsgSeqNum;SET OutputRoot = InputRoot;SET OutputRoot.XML.Test.Result[] =(SELECT T.Column1 AS Column1, T.Column2 AS Column2FROM Database.USERTABLE AS T);72ESQL
DECLARE HDRL INT ;SET HDRL = LENGTH(BITSTREAM(OutputRoot.MQMD));CREATE FIELD OutputRoot."BLOB"."BLOB";DECLARE MSGB BLOB;SET MSGB = SUBSTRING(outMsg FROM HDRL +1);SET OutputRoot."BLOB"."BLOB" = MSGB;END IF;If you want to interrogate or manipulate a bit stream extracted from a database,you must re-create the original message tree. To re-create the XML message treefrom the bit stream, you can use a CREATE statement with a PARSE clause. Theoutput message can then be modified by the message flow.For example, you might create a database table by using the following statement:INSERT INTO Database.TABLE1(MSGDATA, MSGENCODING, MSGCCSID)VALUES (msgBitStream, inEncoding, inCCSID);The following code snippet shows how to re-create the message tree in the XMLNSdomain by using the data read from the table:CALL CopyMessageHeaders();SET Environment.Variables.DBResult = THE( SELECT T.* FROM Database.TABLE1 AS T);DECLARE resultRef REFERENCE TO Environment.Variables.DBResult;IF LASTMOVE(resultRef) THENDECLARE outCCSID INT resultRef.MSGCCSID;DECLARE outEncoding INT resultRef.MSGENCODING;DECLARE outMsg BLOB resultRef.MSGDATA;SET OutputRoot.Properties.CodedCharSetId = outCCSID;SET OutputRoot.Properties.Encoding = outEncoding;CREATE LASTCHILD OF OutputRoot DOMAIN('XMLNS') PARSE(outMsg, outEncoding, outCCSID);-- Now modify the message tree fieldsSET OutputRoot.XMLNS.A.B = 4;SET OutputRoot.XMLNS.A.E = 5;END IF;In the following example, the data is held in a database column with a characterdata type, such as CHAR or VARCHAR. A cast is used to convert the dataextracted from the database into BLOB format. If the bitstream data from thedatabase does not need to be interrogated or manipulated by the message flow, theoutput message can be constructed in the BLOB domain, without any alteration.CALL CopyMessageHeaders();SET Environment.Variables.DBResult = THE( SELECT T.* FROM Database.TABLE1 AS T);DECLARE resultRef REFERENCE TO Environment.Variables.DBResult;IF LASTMOVE(resultRef) THENDECLARE outCCSID INT resultRef.MSGCCSID;DECLARE outMsg BLOB CAST(resultRef.MSGDATA AS BLOB CCSID outCCSID);SET OutputRoot.Properties.CodedCharSetId = outCCSID;SET OutputRoot.Properties.Encoding = resultRef.MSGENCODING;SET OutputRoot.BLOB.BLOB = outMsg;END IF;In the following example, the data is held in a database column with a characterdata type, such as CHAR or VARCHAR. A cast is used to convert the dataextracted from the database into BLOB format. To manipulate or interrogate thisdata within the message flow, you must re-create the original message tree. In thisexample, a CREATE statement with a PARSE clause is used to re-create the XMLmessage tree in the XMLNS domain.CALL CopyMessageHeaders();SET Environment.Variables.DBResult = THE( SELECT T.* FROM Database.TABLE1 AS T);DECLARE resultRef REFERENCE TO Environment.Variables.DBResult;IF LASTMOVE(resultRef) THENDeveloping ESQL73
DECLARE outCCSID INT resultRef.MSGCCSID;DECLARE outEncoding INT resultRef.MSGENCODING;DECLARE outMsg BLOB CAST(resultRef.MSGDATA AS BLOB CCSID outCCSID);SET OutputRoot.Properties.CodedCharSetId = outCCSID;SET OutputRoot.Properties.Encoding = outEncoding;CREATE LASTCHILD OF OutputRoot DOMAIN('XMLNS') PARSE(outMsg, outEncoding, outCCSID);-- Now modify the message tree fieldsSET OutputRoot.XMLNS.A.B = 4;SET OutputRoot.XMLNS.A.E = 5;END IF;Accessing multiple database tablesYou can refer to multiple tables that you have created in the same database. Usethe FROM clause on the SELECT statement to join the data from the two tables.The following example assumes that you have two database tables calledUSERTABLE1 and USERTABLE2. Both tables have two char(6) data type columns(or equivalent).USERTABLE1 contains two rows:Column1Column2Row 1value1value2Row 2value3value4USERTABLE2 contains two rows:Column3Column4Row 1value5value6Row 2value7value8All tables referenced by a single SELECT function must be in the same database.The database can be either the default (specified on the Data Source property ofthe node) or another database (specified on the FROM clause of the SELECTfunction).Configure the Compute, Database, or Filter node that you are using to identify thedatabase in which you have defined the tables. For example, if you are using thedefault database, right-click the node, select Open ESQL, and code the followingESQL statements in the module for this node:This code results in the following output message content:SET OutputRoot.XML.Test.Result[] =(SELECT A.Column1 AS FirstColumn,A.Column2 AS SecondColumn,B.Column3 AS ThirdColumn,B.Column4 AS FourthColumnFROM Database.USERTABLE1 AS A,Database.USERTABLE2 AS BWHERE A.Column1 = 'value1' ANDB.Column4 = 'value8');74ESQL
This example shows how to access data from two database tables. You can codemore complex FROM clauses to access multiple database tables (although all thetables must be in the same database). You can also refer to one or more messagetrees, and can use SELECT to join tables with tables, messages with messages, ortables with messages. “Joining data from messages and database tables” on page96 provides an example of how to merge message data with data in a databasetable.If you specify an ESQL function or procedure on the column identifier in theWHERE clause, it is processed as part of the database query and not as ESQL.Consider the following example:This code attempts to return the rows where the value of Column2 converted touppercase is VALUE2. However, only the database manager can determine the valueof T.Column2 for any given row, therefore it cannot be processed by ESQL beforethe database query is issued, because the WHERE clause determines the rows thatare returned to the message flow.Therefore, the UPPER is passed to the database manager to be included as part ofits processing. However, if the database manager cannot process the token withinthe SELECT statement, an error is returned.Changing database contentYou can use Compute, Database, and Filter nodes to change the contents of adatabase by updating, inserting, or deleting data.The following ESQL code includes statements that show all three operations. Thiscode is appropriate for a Database and Filter node; if you create this code for aCompute node, use the correlation name InputRoot in place of Root.<Test><Result><FirstColumn>value1</FirstColumn><SecondColumn>value2</SecondColumn><ThirdColumn>value7</ThirdColumn><FourthColumn>value8</FourthColumn></Result></Test>SET OutputRoot.XML.Test.Result =THE(SELECT ITEM T.Column1 FROM Database.USERTABLE1 AS TWHERE UPPER(T.Column2) = 'VALUE2');Developing ESQL75
Checking returns to SELECTIf a SELECT function returns no data, or no further data, this result is handled as anormal situation and no error code is set in SQLCODE, regardless of the setting ofthe Throw Exception On Database Error and Treat Warnings As Errors propertieson the current node.To recognize that a SELECT function has returned no data, include ESQL thatchecks what has been returned. You can use various methods:1. EXISTSThis ESQL returns a Boolean value that indicates if a SELECT function returnedone or more values (TRUE), or none (FALSE).IF EXISTS(SELECT T.MYCOL FROM Database.MYTABLE) THEN...2. CARDINALITYIf you expect an array in response to a SELECT, you can use CARDINALITY tocalculate how many entries have been received.SET OutputRoot.XMLNS.Testcase.Results[] = (SELECT T.MYCOL FROM Database.MYTABLE)......IF CARDINALITY (OutputRoot.XMLNS.Testcase.Results[])> 0 THEN........3. IS NULLIf you have used either THE or ITEM keywords in your SELECT function, ascalar value is returned. If no rows have been returned, the value set is NULL.However, it is possible that the value NULL is contained within the column,and you might want to distinguish between these two cases.Distinguish between cases by including COALESCE in the SELECT function,for example:SET OutputRoot.XMLNS.Testcase.Results VALUE = THE (SELECT ITEM COALESCE(T.MYCOL, 'WAS NULL')FROM Database.MYTABLE);If this example returns the character string WAS NULL, it indicates that thecolumn contained NULL, and not that no rows were returned.IF Root.XMLNS.TestCase.Action = 'INSERT' THENINSERT INTO Database.STOCK (STOCK_ID, STOCK_DESC, STOCK_QTY_HELD,BROKER_BUY_PRICE, BROKER_SELL_PRICE, STOCK_HIGH_PRICE, STOCK_HIGH_DATE,STOCK_HIGH_TIME) VALUES(CAST(Root.XMLNS.TestCase.stock_id AS INTEGER),Root.XMLNS.TestCase.stock_desc,CAST(Root.XMLNS.TestCase.stock_qty_held AS DECIMAL),CAST(Root.XMLNS.TestCase.broker_buy_price AS DECIMAL),CAST(Root.XMLNS.TestCase.broker_sell_price AS DECIMAL),Root.XMLNS.TestCase.stock_high_price,CURRENT_DATE,CURRENT_TIME);ELSEIF Root.XMLNS.TestCase.Action = 'DELETE' THENDELETE FROM Database.STOCK WHERE STOCK.STOCK_ID =CAST(Root.XMLNS.TestCase.stock_id AS INTEGER);ELSEIF Root.XMLNS.TestCase.Action = 'UPDATE' THENUPDATE Database.STOCK as A SET STOCK_DESC = Root.XMLNS.TestCase.stock_descWHEREA.STOCK_ID = CAST(Root.XMLNS.TestCase.stock_id AS INTEGER);END IF;76ESQL
In previous releases, an SQLCODE of 100 was set in most cases if no data, or nofurther data, was returned. An exception was raised by the broker if you chose tohandle database errors in the message flow.Committing database updatesWhen you create a message flow that interacts with databases, you can choosewhether the updates that you make are committed when the current node hascompleted processing, or when the current invocation of the message flow hasterminated.For each node, select the appropriate option for the Transaction property to specifywhen its database updates are to be committed:v Choose Automatic (the default) if you want updates made in this node to becommitted or rolled back as part of the whole message flow. The actions thatyou define in the ESQL module are performed on the message and it continuesthrough the message flow. If the message flow completes successfully, theupdates are committed. If the message flow fails, the message and the databaseupdates are rolled back.v Choose Commit if you want to commit the action of the node on the database,irrespective of the success or failure of the message flow as a whole. Thedatabase update is committed when the node processing is successfullycompleted, that is, after all ESQL has been processed, even if the message flowitself detects an error in a subsequent node that causes the message to be rolledback.The value that you choose is implemented for the database tables that you haveupdated. You cannot select a different value for each table.If you have set Transaction to Commit, the behavior of the message flow and thecommitment of database updates can be affected by the use of the PROPAGATEstatement.If you choose to include a PROPAGATE statement in the node's ESQL thatgenerates one or more output message from the node, the processing of thePROPAGATE statement is not considered complete until the entire path that theoutput message takes has completed. This path might include several other nodes,including one or more output nodes. Only then does the node that issues thePROPAGATE statement receive control back and its ESQL terminate. At that point,a database commit is performed, if appropriate.If one of the nodes on the propagated path detects an error and throws anexception, the processing of the node in which you have coded the PROPAGATEstatement never completes. If the error processing results in a rollback, the messageflow and the database update in this node are rolled back. This behavior isconsistent with the stated operation of the Commit option, but might not be thebehavior that you expect.Invoking stored proceduresTo invoke a procedure that is stored in a database, use the ESQL CALL statement.The stored procedure must be defined by a CREATE PROCEDURE statement thathas a Language clause of DATABASE and an EXTERNAL NAME clause thatidentifies the name of the procedure in the database and, optionally, the databaseschema to which it belongs.When you invoke a stored procedure with the CALL statement, the broker ensuresthat the ESQL definition and the database definition match:Developing ESQL77
v The external name of the procedure must match a procedure in the database.v The number of parameters must be the same.v The type of each parameter must be the same.v The direction of each parameter (IN, OUT, INOUT) must be the same.The following restrictions apply to the use of stored procedures:v Overloaded procedures are not supported. (An overloaded procedure is one thathas the same name as another procedure in the same database schema with adifferent number of parameters, or parameters with different types.) If thebroker detects that a procedure has been overloaded, it raises an exception.v In an Oracle stored procedure declaration, you are not permitted to constrainCHAR and VARCHAR2 parameters with a length, and NUMBER parameterswith a precision or scale, or both. Use %TYPE when you declare CHAR,VARCHAR and NUMBER parameters to provide constraints on a formalparameter.You can also invoke a database stored procedure or a database user-definedfunction from a Mapping node. See Mapping a target element from databasestored procedures or Mapping a target element from database user-definedfunctions.Creating a stored procedure in ESQL:When you define an ESQL procedure that corresponds to a database storedprocedure, you can specify either a qualified name (where the qualifier is adatabase schema) or an unqualified name.To create a stored procedure:1. Code a statement similar to this example to create an unqualified procedure:CREATE PROCEDURE myProc1(IN p1 CHAR) LANGUAGE DATABASE EXTERNAL NAME "myProc";The EXTERNAL NAME that you specify must match the definition you havecreated in the database, but you can specify any name you choose for thecorresponding ESQL procedure.2. Code a statement similar to this example to create a qualified procedure:CREATE PROCEDURE myProc2(IN p1 CHAR) LANGUAGE DATABASE EXTERNAL NAME "Schema1.myProc";3. Code a statement similar to this example to create a qualified procedure in anOracle package:CREATE PROCEDURE myProc3(IN p1 CHAR) LANGUAGE DATABASE EXTERNALNAME "mySchema.myPackage.myProc";For examples of stored procedure definitions in the database, see the “CREATEPROCEDURE statement” on page 220.Calling a stored procedure:1. Code a statement similar to this example to invoke an unqualified procedure:CALL myProc1('HelloWorld');Because it is not defined explicitly as belonging to any schema, the myProc1procedure must exist in the default schema (the name of which is the username used to connect to the data source) or the command fails.2. The following example calls the myProc procedure in schema Schema1.CALL myProc2('HelloWorld');78ESQL
3. Code a statement similar to this example to invoke an unqualified procedurewith a dynamic schema:DECLARE Schema2 char 'mySchema2';CALL myProc1('HelloWorld') IN Database.{'Schema2'};This statement calls the myProc1 procedure in database Schema2, overriding thedefault “username” schema.Calling a stored procedure that returns two result sets:To call a stored procedure that takes one input parameter and returns one outputparameter and two result sets:1. Define the procedure with a CREATE PROCEDURE statement that specifiesone input parameter, one output parameter, and two result sets:CREATE PROCEDURE myProc1 (IN P1 INT, OUT P2 INT)LANGUAGE DATABASEDYNAMIC RESULT SETS 2EXTERNAL NAME "myschema.myproc1";2. To invoke the myProc1 procedure using a field reference, code:/* using a field reference */CALL myProc1(InVar1, OutVar2, Environment.ResultSet1[],OutputRoot.XMLNS.Test.ResultSet2[]);3. To invoke the myProc1 procedure using a reference variable, code:/* using a reference variable*/DECLARE cursor REFERENCE TO OutputRoot.XMLNS.Test;CALL myProc1(InVar1, cursor.OutVar2, cursor.ResultSet1[],cursor.ResultSet2[]);Coding ESQL to handle errorsWhen you process messages in a message flow, errors can have a number ofdifferent causes and the message flow designer must decide how to handle thoseerrors.IntroductionWhen you process messages in message flows, errors can have the followingcauses:v External causes; for example, the incoming message is syntactically invalid, adatabase used by the flow has been shut down, or the power supply to themachine on which the broker is running fails.v Internal causes; for example, an attempt to insert a row into a database tablefails because of a constraint check, or a character string that is read from adatabase cannot be converted to a number because it contains alphabeticcharacters.Internal errors can be caused by programs storing invalid data in the database,or by a flaw in the logic of a flow.The message flow designer must decide how to handle errors.Using default error-handlingThe simplest strategy for handling ESQL errors is to do nothing, and use thebroker's default behavior. The default behavior is to cut short the processing of thefailing message, and to proceed to the next message. Input and output nodesprovide options to control exactly what happens when processing is cut short.Developing ESQL79
If the input and output nodes are set to transactional mode, the broker restores thestate before the message is processed:1. The input message that has apparently been taken from the input queue is putback.2. Any output messages that the flow has apparently written to output queues arediscarded.If the input and output nodes are not set to transactional mode:1. The input message that was taken from the input queue is not put back.2. Any output messages that the flow has written to output queues remain on theoutput queues.Each of these strategies has its advantages. The transactional model preserves theconsistency of data, while the non-transactional model maximizes the continuity ofmessage processing. In the transactional model, the failing input message is putback onto the input queue, and the broker attempts to process it again. The mostlikely outcome of this scenario is that the message continues to fail until the retrylimit is reached, at which point the message is placed on a dead letter queue. Thereason for the failure to process the message is logged to the system event log(Windows) or syslog (UNIX®). Therefore, the failing message holds up theprocessing of subsequent valid messages, and is left unprocessed by the broker.Most databases operate transactionally so that all changes that are made todatabase tables are committed if the processing of the message succeeds, or rolledback if it fails, therefore maintaining the integrity of data. An exception to thissituation is if the broker itself, or a database, fails (for example, the power to thecomputers on which they are running is interrupted). In these cases, changes mightbe committed in some databases, but not in others, or the database changes mightbe committed but the input and output messages are not committed. If thesepossibilities concern you, make the flow coordinated and configure the databasesthat are involved.Using customized error handlingThe following list contains some general tips for creating customized errorhandlers.v If you require something better than default error handling, the first step is touse a handler; see “DECLARE HANDLER statement” on page 240. Create onehandler per node to intercept all possible exceptions (or all those that you canpredict).v Having intercepted an error, the error handler can use whatever logic isappropriate to handle it. Alternatively, it can use a THROW statement or node tocreate an exception, which could be handled higher in the flow logic, or evenreach the input node, causing the transaction to be rolled back; see “Throwingan exception” on page 83.v If a node generates an exception that is not caught by the handler, the flow isdiverted to the Failure terminal, if one is connected, or handled by defaulterror-handling if no Failure terminal is connected.Use Failure terminals to catch unhandled errors. Attach a simple logic flow tothe Failure terminal. This logic flow could consist of a database or Computenode that writes a log record to a database (possibly including the message's bitstream), or writes a record to the event log. The flow could also contain anoutput node that writes the message to a special queue.The full exception tree is passed to any node that is connected to a Failureterminal; see Exception list tree structure.80ESQL
v Your error handlers are responsible for logging each error in an appropriateplace, such as the system event log.For a detailed description of the options that you can use to process errors in amessage flow, see Handling errors in message flows. For examples of what you cando, see “Throwing an exception” on page 83 and “Capturing database state” onpage 84.Writing code to detect errorsThe following sections assume that the broker detects the error. It is possible,however, for the logic of the flow to detect an error. For example, when coding theflow logic, you could use the following elements:v IF statements that are inserted specifically to detect situations that should notoccurv The ELSE clause of a case expression or statement to trap routes through thecode that should not be possibleAs an example of a flow logic-detected error, consider a field that has a range ofpossible integer values that indicate the type of message. It would not be goodpractice to leave to chance what would happen if a message were to arrive inwhich the field's value did not correspond to any known type of message. Oneway this situation could occur is if the system is upgraded to support extra typesof message, but one part of the system is not upgraded.Using your own logic to handle input messages that are not validInput messages that are syntactically invalid (and input messages that appear to benot valid because of erroneous message format information) are difficult to dealwith, because the broker cannot determine the contents of the message. Typically,the best way to deal with these messages is to configure the input node to fullyparse and validate the message. However, this configuration applies only topredefined messages; that is, MRM or IDoc.If the input node is configured in this way, the following results are guaranteed ifthe input message cannot be parsed successfully:v The input message never emerges from the node's normal output terminal (itgoes to the Failure terminal).v The input message never enters the main part of the message flow.v The input message never causes any database updates.v No messages are written to any output queues.To deal with a failing message, connect a simple logic flow to the Failure terminal.The only disadvantage to this strategy is that if the normal flow does not requireaccess to all of the message's fields, the forcing of complete parsing of the messageaffects performance.Using your own logic to handle database errorsDatabase errors fall into three categories:v The database is not working (for example, it is off line).v The database is working but refuses your request (for example, a lock contentionoccurs).v The database is working but it cannot do what you request (for example, readfrom a non-existent table).Developing ESQL81
If you require something better than default error handling, the first step is to usea handler (see “DECLARE HANDLER statement” on page 240) to intercept theexception. The handler can determine the nature of the failure from the SQL statethat is returned by the database.A database is not workingIf a database is not working at all, and is essential to the processing ofmessages, there is typically not much that you can do. The handler, havingdetermined the cause, might complete one or more of the following actions:v Use the RESIGNAL statement to re-throw the original error, thereforeallowing the default error handler to take overv Use a different databasev Write the message to a special output queueBe careful if you use an approach similar to this technique; the handlerabsorbs the exception, therefore all changes to other databases, or writes toqueues, are committed.A database refuses your requestThe situation when a lock contention occurs is similar to the “Database notworking” case because the database will have backed out all the databasechanges that you have made for the current message, not just the failingrequest. Therefore, unless you are sure that this was the only update, defaulterror-handling is typically the best strategy, except possibly logging the erroror passing the message to a special queue.Impossible requestsAn impossible request occurs when the database is working, but cannotcomplete the requested action. This type of error covers a wide variety ofproblems.If, as discussed in the previous example, the database does not have a table ofthe name that the flow expects, default error-handling is typically the beststrategy, except possibly logging the error or passing the message to a specialqueue.Many other errors might be handled successfully, however. For example, anattempt to insert a row might fail because there is already such a row and thenew row would be a duplicate. Or an attempt to update a row might failbecause there is no such row (that is, the update action updated zero rows). Inthese cases, the handler can incorporate whatever logic you think appropriate.It might insert the missing row, or use the existing one (possibly making surethe values in it are suitable).If you want an update of zero rows to be reported as an error, you must setthe Treat warnings as errors property on the node to true, which is not thedefault setting.Using your own logic to handle errors in output nodesErrors that occur in MQOutput nodes report the nature of the error in the SQLstate and give additional information in the SQL native error variable. Therefore, ifsomething better than default error handling is required, the first step is to use ahandler (see “DECLARE HANDLER statement” on page 240) to intercept theexception. Such a handler typically surrounds only a single PROPAGATEstatement.82ESQL
Using your own logic to handle other errorsBesides those errors covered above, a variety of other errors can occur. Forexample, an arithmetic calculation might overflow, a cast might fail because of theunsuitability of the data, or an access to a message field might fail because of atype constraint. The broker offers two programming strategies for dealing withthese types of error.v The error causes an exception that is either handled or left to roll back thetransaction.v The failure is recorded as a special value that is tested for later.In the absence of a type constraint, an attempt to access a non-existent messagefield results in the value null. Null values propagate through expressions, makingthe result null. Therefore, if an expression, however complex, does not return anull value, you know that all the values that it needed to calculate its result werenot null.Cast expressions can have a default clause. If there is a default clause, casts failquietly; instead of throwing an exception, they simply return the default value. Thedefault value could be an innocuous number (for example, zero for an integer), ora value that is clearly invalid in the context (for example, -1 for a customernumber). Null might be particularly suitable because it is a value that is differentfrom all others, and it will propagate through expressions without any possibilityof the error condition being masked.Handling errors in other nodesExceptions that occur in other nodes (that is, downstream of a PROPAGATEstatement) might be caught by handlers in the normal way. Handling such errorsintelligently, however, poses a problem: another node was involved in the originalerror, therefore another node, and not necessarily the originator of the exception, islikely to be involved in handling the error.To help in these situations, the Database and Compute nodes have four terminalscalled Out1, Out2, Out3, and Out4. In addition, the syntax of the PROPAGATEstatement includes target expression, message source, and control clauses to givemore control over these terminals.Throwing an exceptionIf you detect an error or other situation in your message flow in which you wantmessage processing to be ended, you can throw an exception in a message flow intwo ways.v Use the ESQL THROW EXCEPTION statement.Include the THROW statement anywhere in the ESQL module for a Compute,Database, or Filter node. Use the options on the statement to code your owndata to be inserted into the exception.v Include a THROW node in your message flow.Set the node properties to identify the source and content of the exception.By using either statement options or node properties, you can specify a messageidentifier and values that are inserted into the message text to give additionalinformation and identification to users who interpret the exception. You can specifyany message in any catalog that is available to the broker. See Using error loggingfrom a user-defined extension for more information.Developing ESQL83
The situations in which you might want to throw an exception are determined bythe behavior of the message flow; decide when you design the message flowwhere this action might be appropriate. For example, you might want to examinethe content of the input message to ensure that it meets criteria that cannot bedetected by the input node (which might check that a particular message format isreceived).The following example uses the example Invoice message to show how you canuse the ESQL THROW statement. To check that the invoice number is within aparticular range, throw an exception for any invoice message received that doesnot fall in the valid range.Capturing database stateIf an error occurs when the broker accesses an external database, you can either letthe broker throw an exception during node processing or use ESQL statements toprocess the exception within the node itself.Letting the broker throw an exception during node processing is the default action;ESQL processing in the current node is abandoned. The exception is thenpropagated backwards through the message flow until an enclosing catch node, orthe input node for this message flow, is reached. If the exception reaches the inputnode, an active transaction is rolled back.Using ESQL statements to process the exception within the node itself requires anunderstanding of database return codes and a logical course of action to take whenan error occurs. To enable this inline database error processing, you must clear theFilter, Database, or Compute node's Throw Exception On Database Error property.If you clear this property, the node sets the database state indicators SQLCODE,SQLSTATE, SQLNATIVEERROR, and SQLERRORTEXT, with appropriateinformation from the database manager instead of throwing an exception.The indicators contain information only when an error (not a warning) occurs,unless you have selected the Treat Warnings As Errors property. If a databaseoperation is successful, or returns success with information, the indicators containtheir default success values.You can use the values contained in these indicators in ESQL statements to makedecisions about the action to take. You can access these indicators with theSQLCODE, SQLSTATE, SQLNATIVEERROR, and SQLERRORTEXT functions.If you are attempting inline error processing, check the state indicators after eachdatabase statement is executed to ensure that you catch and assess all errors. Whenprocessing the indicators, if you meet an error that you cannot handle inline, you--Check for invoice number lower than permitted rangeIF Body.Invoice.InvoiceNo< 100000 THENTHROW USER EXCEPTION CATALOG 'MyCatalog' MESSAGE 1234 VALUES('Invoice number too low', Body.Invoice.InvoiceNo);-- Check for invoice number higher than permitted rangeELSEIF Body.InvoiceNo> 500000 THENTHROW USER EXCEPTION CATALOG 'MyCatalog' MESSAGE 1235 VALUES('Invoice number too high', Body.Invoice.InvoiceNo);ELSE DO-- invoice number is within permitted range-- complete normal processingENDIF;84ESQL
can raise a new exception either to deal with it upstream in a catch node, or to letit through to the input node so that the transaction is rolled back, for which youcan use the ESQL THROW statement.You might want to check for the special case in which a SELECT returns no data.This situation is not considered an error and SQLCODE is not set, therefore youmust test explicitly for it; see “Checking returns to SELECT” on page 76.Using ESQL to access database state indicatorsThe following ESQL example shows how to use the four database state functions,and how to include the error information that is returned in an exception:DECLARE SQLState1 CHARACTER;DECLARE SQLErrorText1 CHARACTER;DECLARE SQLCode1 INTEGER;DECLARE SQLNativeError1 INTEGER;-- Make a database insert to a table that does not exist --INSERT INTO Database.DB2ADMIN.NONEXISTENTTABLE (KEY,QMGR,QNAME)VALUES (45,'REG356','my TESTING 2');--Retrieve the database return codes --SET SQLState1 = SQLSTATE;SET SQLCode1 = SQLCODE;SET SQLErrorText1 = SQLERRORTEXT;SET SQLNativeError1 = SQLNATIVEERROR;--Use the THROW statement to back out the database and issue a user exception--THROW USER EXCEPTION MESSAGE 2950 VALUES( 'The SQL State' , SQLState1 , SQLCode1 , SQLNativeError1 ,SQLErrorText1 );You do not have to throw an exception when you detect a database error; youmight prefer to save the error information returned in the local environment tree,and include a Filter node in your message flow that routes the message to error orsuccess subflows according to the values saved.The following sample program provides another example of ESQL that uses thesedatabase functions:v Airline ReservationsYou can view samples information only when you use the information center thatis integrated with the Message Broker Toolkit or the online information center.Using the SELECT functionThe SELECT function is a convenient and powerful tool for accessing fields andtransforming data in a message tree.The following topics show by example how to use the SELECT function totransform a variety of messages. The examples are based on an XML inputmessage that has been parsed in the XMLNS domain. However, the techniquesshown in these topics can be applied to any message tree.v “Transforming a simple message” on page 86v “Transforming a complex message” on page 89v “Returning a scalar value in a message” on page 91v “Joining data in a message” on page 93v “Translating data in a message” on page 95Developing ESQL85
v “Joining data from messages and database tables” on page 96Transforming a simple messageWhen you code the ESQL for a Compute node, use the SELECT function totransform simple messages.This topic provides examples of simple message transformation. Review theexamples and modify them for your own use. They are all based on the Invoicemessage as input.Consider the following ESQL:When this ESQL code processes the Invoice message, it produces the followingoutput message:Three Output fields are present, one for each Item field, because SELECT createsan item in its result list for each item described by its FROM list. Within eachOutput field, a Field is created for each field named in the SELECT clause. Thesefields are in the order in which they are specified within the SELECT clause, not inthe order in which they appear in the incoming message.The R that is introduced by the final AS keyword is known as a correlation name.It is a local variable that represents in turn each of the fields addressed by theFROM clause. The name chosen has no significance. In summary, this simpletransform does two things:1. It discards unwanted fields.2. It guarantees the order of the fields.You can perform the same transform with a procedural algorithm:These examples show that the SELECT version of the transform is much moreconcise. It also executes faster.SET OutputRoot.XMLNS.Data.Output[] =(SELECT R.Quantity, R.Author FROM InputRoot.XMLNS.Invoice.Purchases.Item[] AS R);<Data><Output><Quantity>2</Quantity><Author>Neil Bradley</Author></Output><Output><Quantity>1</Quantity><Author>Don Chamberlin</Author></Output><Output><Quantity>1</Quantity><Author>Philip Heller, Simon Roberts</Author></Output></Data>DECLARE i INTEGER 1;DECLARE count INTEGER CARDINALITY(InputRoot.XMLNS.Invoice.Purchases.Item[]);WHILE (i <= count)SET OutputRoot.XMLNS.Data.Output[i].Quantity = InputRoot.XMLNS.Invoice.Purchases.Item[i].Quantity;SET OutputRoot.XMLNS.Data.Output[i].Author= InputRoot.XMLNS.Invoice.Purchases.Item[i].Author;SET i = i+1;END WHILE;86ESQL
The following example shows a more advanced transformation:In this transform, an AS clause is associated with each item in the SELECT clause.This clause gives each field in the result an explicit name rather than a field namethat is inherited from the input. These names can be paths (that is, a dot-separatedlist of names), as shown in the example. The structure of the output messagestructure can be different from the input message. Using the same Invoice message,the result is:The expressions in the SELECT clause can be of any complexity and there are nospecial restrictions. They can include operators, functions, and literals, and theycan refer to variables or fields that are not related to the correlation name. Thefollowing example shows more complex expressions:Using the same Invoice message, the result in this case is:SET OutputRoot.XMLNS.Data.Output[] =(SELECT R.Quantity AS Book.Quantity,R.AuthorAS Book.AuthorFROM InputRoot.XMLNS.Invoice.Purchases.Item[] AS R);<Data><Output><Book><Quantity>2</Quantity><Author>Neil Bradley</Author></Book></Output><Output><Book><Quantity>1</Quantity><Author>Don Chamberlin</Author></Book></Output><Output><Book><Quantity>1</Quantity><Author>Philip Heller, Simon Roberts</Author></Book></Output></Data>SET OutputRoot.XMLNS.Data.Output[] =(SELECT 'Start'AS Header,'Number of books:' || R.Quantity AS Book.Quantity,R.Author || ':Name and Surname'AS Book.Author,'End'AS TrailerFROM InputRoot.XMLNS.Invoice.Purchases.Item[] AS R);Developing ESQL87||||||||||||||||||||
As shown above, the AS clauses of the SELECT clause contain a path thatdescribes the full name of the field that is to be created in the result. These pathscan also specify (as is normal for paths) the type of field that is to be created. Thefollowing example transform specifies the field types. In this case, XML taggeddata is transformed to XML attributes:Using the same Invoice message, the result is:Finally, you can use a WHERE clause to eliminate some of the results. In thefollowing example a WHERE clause is used to remove results in which a specificcriterion is met. An entire result is either included or excluded:<Data><Output><Header>Start</Header><Book><Quantity>Number of books:2</Quantity><Author>Neil Bradley:Name and Surname</Author></Book><Trailer>End</Trailer></Output><Output><Header>Start</Header><Book><Quantity>Number of books:1</Quantity><Author>Don Chamberlin:Name and Surname</Author></Book><Trailer>End</Trailer></Output><Output><Header>Start</Header><Book><Quantity>Number of books:1</Quantity><Author>Philip Heller, Simon Roberts:Name and Surname</Author></Book><Trailer>End</Trailer></Output></Data>SET OutputRoot.XMLNS.Data.Output[] =(SELECT R.Quantity.* AS Book.(XML.Attribute)Quantity,R.Author.*AS Book.(XML.Attribute)AuthorFROM InputRoot.XMLNS.Invoice.Purchases.Item[] AS R);<Data><Output><Book Quantity="2" Author="Neil Bradley"/></Output><Output><Book Quantity="1" Author="Don Chamberlin"/></Output><Output><Book Quantity="1" Author="Philip Heller, Simon Roberts"/></Output></Data>SET OutputRoot.XMLNS.Data.Output[] =(SELECT R.Quantity AS Book.Quantity,R.AuthorAS Book.AuthorFROM InputRoot.XMLNS.Invoice.Purchases.Item[] AS RWHERE R.Quantity = 2);88ESQL
Using the same input message, the result is:Transforming a complex messageWhen you code the ESQL for a Compute node, use the SELECT function forcomplex message transformation.This topic provides examples of complex message transformation. Review theexamples and modify them for your own use. They are all based on the Invoicemessage as input.In this example, Invoice contains a variable number of Items. The transform isshown in the following example:The output message that is generated is:<Data><Output><Book><Quantity>2</Quantity><Author>Neil Bradley</Author></Book></Output></Data>SET OutputRoot.XMLNS.Data.Statement[] =(SELECT I.Customer.TitleAS Customer.Title,I.Customer.FirstName || ' ' || I.Customer.LastNameAS Customer.Name,COALESCE(I.Customer.PhoneHome,'')AS Customer.Phone,(SELECT II.TitleAS Desc,CAST(II.UnitPrice AS FLOAT) * 1.6 AS Cost,II.QuantityAS QtyFROM I.Purchases.Item[] AS IIWHEREII.UnitPrice> 0.0)AS Purchases.Article[],(SELECT SUM( CAST(II.UnitPrice AS FLOAT) *CAST(II.QuantityAS FLOAT) *1.6)FROM I.Purchases.Item[] AS II)AS Amount,'Dollars'AS Amount.(XML.Attribute)CurrencyFROM InputRoot.XMLNS.Invoice[] AS IWHERE I.Customer.LastName <> 'Brown');Developing ESQL89
This transform has nested SELECT clauses. The outer statement operates on the listof Invoices. The inner statement operates on the list of Items. The AS clause that isassociated with the inner SELECT clause expects an array:This statement tells the outer SELECT clause to expect a variable number of Itemsin each result. Each SELECT clause has its own correlation name: I for the outerSELECT clause and II for the inner one. Each SELECT clause typically uses its owncorrelation name, but the FROM clause in the inner SELECT clause refers to thecorrelation name of the outer SELECT clause:This statement tells the inner SELECT clause to work with the current Invoice'sItems. Both SELECT clauses contain WHERE clauses. The outer one uses onecriterion to discard certain Customers, and the inner one uses a different criterionto discard certain Items. The example also shows the use of COALESCE to preventmissing input fields from causing the corresponding output field to be missing.Finally, it also uses the column function SUM to add together the value of all Itemsin each Invoice. Column functions are discussed in “Referencing columns in adatabase” on page 68.<Data><Statement><Customer><Title>Mr</Title><Name>Andrew Smith</Name><Phone>01962818000</Phone></Customer><Purchases><Article><Desc Category="Computer" Form="Paperback" Edition="2">The XML Companion</Desc><Cost>4.472E+1</Cost><Qty>2</Qty></Article><Article><Desc Category="Computer" Form="Paperback" Edition="2">A Complete Guide to DB2 Universal Database</Desc><Cost>6.872E+1</Cost><Qty>1</Qty></Article><Article><Desc Category="Computer" Form="Hardcover" Edition="0">JAVA 2 Developers Handbook</Desc><Cost>9.5984E+1</Cost><Qty>1</Qty></Article></Purchases><Amount Currency="Dollars">2.54144E+2</Amount></Statement></Data>(SELECT II.TitleAS Desc,CAST(II.UnitPrice AS FLOAT) * 1.6 AS Cost,II.QuantityAS QtyFROM I.Purchases.Item[] AS IIWHEREII.UnitPrice> 0.0)-- Note the use of [] in the next expressionAS Purchases.Article[],(SELECT II.TitleAS Desc,CAST(II.UnitPrice AS FLOAT) * 1.6 AS Cost,II.QuantityAS Qty-- Note the use of I.Purchases.Item in the next expressionFROM I.Purchases.Item[] AS IIWHEREII.UnitPrice> 0.0) AS Purchases.Article[],90ESQL
When the fields Desc are created, the whole of the input Title field is copied: theXML attributes and the field value. If you do not want these attributes in theoutput message, use the FIELDVALUE function to discard them; for example, codethe following ESQL:That code generates the following output message:Returning a scalar value in a messageUse a SELECT statement to return a scalar value by including both the THE andITEM keywords.For example:Use of the ITEM keyword:SET OutputRoot.XMLNS.Data.Statement[] =(SELECT I.Customer.TitleAS Customer.Title,I.Customer.FirstName || ' ' || I.Customer.LastName AS Customer.Name,COALESCE(I.Customer.PhoneHome,'')AS Customer.Phone,(SELECT FIELDVALUE(II.Title)AS Desc,CAST(II.UnitPrice AS FLOAT) * 1.6 AS Cost,II.QuantityAS QtyFROM I.Purchases.Item[] AS IIWHEREII.UnitPrice> 0.0)AS Purchases.Article[],(SELECT SUM( CAST(II.UnitPrice AS FLOAT) *CAST(II.QuantityAS FLOAT) *1.6)FROM I.Purchases.Item[] AS II) AS Amount,'Dollars'AS Amount.(XML.Attribute)CurrencyFROM InputRoot.XMLNS.Invoice[] AS IWHERE I.Customer.LastName <> 'Brown');<Data><Statement><Customer><Title>Mr</Title><Name>Andrew Smith</Name><Phone>01962818000</Phone></Customer><Purchases><Article><Desc>The XML Companion</Desc><Cost>4.472E+1</Cost><Qty>2</Qty></Article><Article><Desc>A Complete Guide to DB2 Universal Database</Desc><Cost>6.872E+1</Cost><Qty>1</Qty></Article><Article><Desc>JAVA 2 Developers Handbook</Desc><Cost>9.5984E+1</Cost><Qty>1</Qty></Article></Purchases><Amount Currency="Dollars">2.54144E+2</Amount></Statement></Data>1 + THE(SELECT ITEM T.a FROM Body.Test.A[] AS T WHERE T.b = '123')Developing ESQL91
The following example shows the use of the ITEM keyword to select one item andcreate a single value.When the Invoice message is received as input, the ESQL shown generates thefollowing output message:When the ITEM keyword is specified, the output message includes a list of scalarvalues. Compare this message to the one that is produced if the ITEM keyword isomitted, in which a list of fields (name-value pairs) is generated:Effects of the THE keyword:The THE keyword converts a list containing one item to the item itself.The two previous examples both specified a list as the source of the SELECT in theFROM clause (the field reference has [] at the end to indicate an array), so typicallythe SELECT function generates a list of results. Because of this behavior, you mustspecify a list as the target of the assignment (thus the "Result[]" as the target of theassignment). However, you often know that the WHERE clause that you specify aspart of the SELECT returns TRUE for only one item in the list. In this case use theTHE keyword.The following example shows the effect of using the THE keyword:The THE keyword means that the target of the assignment becomesOutputRoot.XMLNS.Test.Result (the "[]" is not permitted). Its use generates thefollowing output message:SET OutputRoot.MQMD = InputRoot.MQMD;SET OutputRoot.XMLNS.Test.Result[] =(SELECT ITEM T.UnitPrice FROM InputBody.Invoice.Purchases.Item[] AS T);<Test><Result>27.95</Result><Result>42.95</Result><Result>59.99</Result></Test><Test><Result><UnitPrice>27.95</UnitPrice></Result><Result><UnitPrice>42.95</UnitPrice></Result><Result><UnitPrice>59.99</UnitPrice></Result></Test>SET OutputRoot.MQMD = InputRoot.MQMD;SET OutputRoot.XMLNS.Test.Result =THE (SELECT T.Publisher, T.Author FROM InputBody.Invoice.Purchases.Item[]AS T WHERE T.UnitPrice = 42.95);92ESQL
Selecting from a list of scalars:Consider the following sample input message:If you code the following ESQL statements to process this message:the following output message is generated:Joining data in a messageThe FROM clause of a SELECT function is not restricted to having one item.Specifying multiple items in the FROM clause produces the typical Cartesianproduct joining effect, in which the result includes an item for all combinations ofitems in the two lists.Using the FROM clause in this way produces the same joining effect as standardSQL.The Invoice message includes a set of customer details, payment details, anddetails of the purchases that the customer makes. Code the following ESQL toprocess the input Invoice message:The following output message is generated:<Test><Result><Publisher>Morgan Kaufmann Publishers</Publisher><Author>Don Chamberlin</Author></Result></Test><Test><A>1</A><A>2</A><A>3</A><A>4</A><A>5</A></Test>SET OutputRoot.XMLNS.Test.A[] =(SELECT ITEM A from InputBody.Test.A[]WHERE CAST(A AS INTEGER) BETWEEN 2 AND 4);<A>2</A><A>3</A><A>4</A>SET OutputRoot.XMLNS.Items.Item[] =(SELECT D.LastName, D.Billing,P.UnitPrice, P.QuantityFROM InputBody.Invoice.Customer[] AS D,InputBody.Invoice.Purchases.Item[] AS P);Developing ESQL93
Three results are produced, giving the number of descriptions in the first list (one)multiplied by the number of prices in the second (three). The results systematicallywork through all the combinations of the two lists. You can see this by looking atthe LastName and UnitPrice fields selected from each result:You can join data that occurs in a list and a non-list, or in two non-lists, and so on.For example:The location of the [] in each case is significant. Any number of items can bespecified in the FROM clause, not just one or two. If any of the items specify [] toindicate a list of items, the SELECT function returns a list of results (the list mightcontain only one item, but the SELECT function can return a list of items).The target of the assignment must specify a list (so must end in []), or you mustuse the “THE function” on page 328 if you know that the WHERE clauseguarantees that only one combination is matched.<Items><Item><LastName>Smith</LastName><Billing><Address>14 High Street</Address><Address>Hursley Village</Address><Address>Hampshire</Address><PostCode>SO213JR</PostCode></Billing><UnitPrice>27.95</UnitPrice><Quantity>2</Quantity></Item><Item><LastName>Smith</LastName><Billing><Address>14 High Street</Address><Address>Hursley Village</Address><Address>Hampshire</Address><PostCode>SO213JR</PostCode></Billing><UnitPrice>42.95</UnitPrice><Quantity>1</Quantity></Item><Item><LastName>Smith</LastName><Billing><Address>14 High Street</Address><Address>Hursley Village</Address><Address>Hampshire</Address><PostCode>SO213JR</PostCode></Billing><UnitPrice>59.99</UnitPrice><Quantity>1</Quantity></Item></Items>LastName SmithUnitPrice 27.95LastName SmithUnitPrice 42.95LastName SmithUnitPrice 59.99OutputRoot.XMLNS.Test.Result1[] =(SELECT ... FROM InputBody.Test.A[], InputBody.Test.b);OutputRoot.XMLNS.Test.Result1 =(SELECT ... FROM InputBody.Test.A, InputBody.Test.b);94ESQL
Translating data in a messageYou can translate data from one form to another.A typical example of the requirement to translate data is if the items are known inone message by names, and in another message by numbers. For example:Consider the following input message:This message has two sections; the first section is a list of items in which each itemhas a catalogue number and a type; the second section is a table for translatingbetween descriptive type names and numeric type codes. Include a Compute nodewith the following transform:The following output message is generated:Type NameType CodeConfectionary2000Newspapers3000Hardware4000<Data><Items><Item><Cat>1000</Cat><Description>Milk Chocolate Bar</Description><Type>Confectionary</Type></Item><Item><Cat>1001</Cat><Description>Daily Newspaper</Description><Type>NewsPapers</Type></Item><Item><Cat>1002</Cat><Description>Kitchen Sink</Description><Type>Hardware</Type></Item></Items><TranslateTable><Translate><Name>Confectionary</Name><Number>2000</Number></Translate><Translate><Name>NewsPapers</Name><Number>3000</Number></Translate><Translate><Name>Hardware</Name><Number>4000</Number></Translate></TranslateTable></Data>SET OutputRoot.XMLNS.Result.Items.Item[] =(SELECT M.Cat, M.Description, T.Number As TypeFROMInputRoot.XMLNS.Data.Items.Item[]As M,InputRoot.XMLNS.Data.TranslateTable.Translate[] As TWHERE M.Type = T.Name);Developing ESQL95
In the result, each type name has been converted to its corresponding code. In thisexample, both the data and the translate table were in the same message tree,although this is not a requirement. For example, the translate table could be codedin a database, or might have been set up in LocalEnvironment by a previousCompute node.Joining data from messages and database tablesYou can use SELECT functions that interact with both message data and databases.You can also nest a SELECT function that interacts with one type of data within aSELECT clause that interacts with the other type.Consider the following input message, which contains invoice information for twocustomers:Consider the following database tables, Prices and Addresses, and their contents:<Result><Items><Item><Cat>1000</Cat><Description>Milk Chocolate Bar</Description><Type>2000</Type></Item><Item><Cat>1001</Cat><Description>Daily Newspaper</Description><Type>3000</Type></Item><Item><Cat>1002</Cat><Description>Kitchen Sink</Description><Type>4000</Type></Item></Items></Result><Data><Invoice><CustomerNumber>1234</CustomerNumber><Item><PartNumber>1</PartNumber><Quantity>9876</Quantity></Item><Item><PartNumber>2</PartNumber><Quantity>8765</Quantity></Item></Invoice><Invoice><CustomerNumber>2345</CustomerNumber><Item><PartNumber>2</PartNumber><Quantity>7654</Quantity></Item><Item><PartNumber>1</PartNumber><Quantity>6543</Quantity></Item></Invoice></Data>96ESQL
If you code the following ESQL transform:the following output message is generated. The input message is augmented withthe price and address information from the database table:PARTNOPRICE----------- ------------------------1+2.50000E+0012+6.50000E+00PARTNOSTREETCITYCOUNTRY----------------------------------------------123422 Railway CuttingsEast CheamEngland2345The WarrenWatership DownEngland-- Create a valid output messageSET OutputRoot.MQMD = InputRoot.MQMD;-- Select suitable invoicesSET OutputRoot.XMLNS.Data.Statement[] =(SELECT I.CustomerNumberAS Customer.Number,A.StreetAS Customer.Street,A.CityAS Customer.Town,A.CountryAS Customer.Country,-- Select suitable items(SELECT II.PartNumber AS PartNumber,II.QuantityAS Quantity,PI.PriceAS PriceFROM Database.db2admin.Prices AS PI,I.Item[]AS IIWHERE II.PartNumber = PI.PartNo)AS Purchases.Item[]FROM Database.db2admin.AddressesAS A,InputRoot.XMLNS.Data.Invoice[] AS IWHERE I.CustomerNumber = A.PartNo);Developing ESQL97
You can nest the database SELECT clause within the message SELECT clause. Inmost cases, the code is not as efficient as the previous example, but you might findthat it is better if the messages are small and the database tables are large.<Data><Statement><Customer><Number>1234</Number><Street>22 Railway Cuttings</Street><Town>East Cheam</Town><Country>England</Country></Customer><Purchases><Item><PartNumber>1</PartNumber><Quantity>9876</Quantity><Price>2.5E+1</Price></Item><Item><PartNumber>2</PartNumber><Quantity>8765</Quantity><Price>6.5E+1</Price></Item></Purchases></Statement><Statement><Customer><Number>2345</Number><Street>The Warren</Street><Town>Watership Down</Town><Country>England</Country></Customer><Purchases><Item><PartNumber>1</PartNumber><Quantity>6543</Quantity><Price>2.5E+1</Price></Item><Item><PartNumber>2</PartNumber><Quantity>7654</Quantity><Price>6.5E+1</Price></Item></Purchases></Statement></Data>98ESQL